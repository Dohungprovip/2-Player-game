<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple MOBA</title>
  <style>
    /* T·ªïng th·ªÉ */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e1e1e, #444);
      color: #fff;
    }
    /* Scoreboard */
    #scoreboard {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      z-index: 1001;
      background: rgba(0,0,0,0.7);
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.8);
    }
    /* N√∫t quay l·∫°i menu */
    #menuButton {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1001;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background: linear-gradient(135deg, #555, #777);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      transition: background 0.3s ease;
    }
    #menuButton:hover {
      background: linear-gradient(135deg, #777, #999);
    }
    /* Cooldown timer */
    .cooldown-timer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      opacity: 1 !important;
    }
    /* Canvas */
    canvas {
      display: block;
      margin: 80px auto 20px auto;
      border: 2px solid #fff;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
      background: #444;
    }
    /* (C√°c style zone, skill slots, ‚Ä¶ gi·ªØ nguy√™n) */
    /* Overlay chung */
    .overlay-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.5s ease;
      padding: 20px;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .overlay-screen input,
    .overlay-screen button {
      padding: 10px;
      margin: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
    }
    .overlay-screen input { width: 250px; }
    .overlay-screen button {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      background: linear-gradient(135deg, #555, #777);
      color: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      transition: background 0.3s ease;
    }
    .overlay-screen button:hover {
      background: linear-gradient(135deg, #777, #999);
    }
    /* Giao di·ªán ch·ªçn class */
    #characterSelectScreen {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    #characterOptions {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      width: 90%;
      padding: 10px;
    }
    .class-btn {
      border: 2px solid #fff;
      padding: 10px;
      border-radius: 10px;
      width: 100px;
      height: 100px;
      text-align: center;
      cursor: pointer;
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    .class-btn:hover {
      background-color: gold;
    }
    .class-btn.active {
      border-color: gold;
    }
    /* Giao di·ªán nh·∫≠p t√™n */
    #nameScreen {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    #nameInputs {
      display: flex;
      gap: 20px;
    }
    /* Giao di·ªán ch·ªù tr·∫≠n v·ªõi panel s·∫µn s√†ng */
    #waitingScreen {
      display: none;
      flex-direction: column;
    }
    #readyPanel {
      display: none;
      text-align: center;
      margin-top: 20px;
    }
    #readyTimer {
      font-size: 24px;
      margin-bottom: 20px;
    }
    .ready-box {
      width: 150px;
      padding: 10px;
      margin: 10px auto;
      background-color: gray;
      color: #fff;
      border-radius: 5px;
    }
    .ready-box.ready {
      background-color: limegreen;
    }
    .spinner {
      margin-top: 20px;
    }
    /* Overlay Load Tr·∫≠n m·ªõi */
    #matchLoadingScreen {
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #topPlayerPanel {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 20px;
    }
    #bottomPlayerPanel {
      position: absolute;
      bottom: 20px;
      right: 20px;
      font-size: 20px;
    }
    #matchCountdown {
      font-size: 36px;
      margin-top: 50px;
    }
    /* Skill slots cho local player */
    #skillContainer {
      position: fixed;
      right: 20px;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1002;
    }
    .skill-slot {
      position: relative;
      width: 60px;
      height: 60px;
      border: 2px solid #fff;
      border-radius: 10px;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .skill-icon {
      font-size: 32px;
      z-index: 1;
    }
  </style>
</head>
<body>
  <!-- Scoreboard -->
  <div id="scoreboard">Score: 0</div>
  <button id="menuButton">Quay l·∫°i menu</button>
  
  <!-- Start Screen -->
  <div id="startScreen" class="overlay-screen">
    <h1>Simple MOBA</h1>
    <div class="menu">
      <button id="startMenuButton">B·∫Øt ƒë·∫ßu</button>
      <button id="instructionButton">H∆∞·ªõng d·∫´n</button>
      <button id="infoButton">Th√¥ng tin nh√¢n v·∫≠t</button>
    </div>
  </div>
  
  <!-- Character Selection Screen -->
  <div id="characterSelectScreen" class="overlay-screen">
    <h1>Ch·ªçn Class</h1>
    <div id="characterOptions">
      <div class="class-btn active" data-class="knight">Knight</div>
      <div class="class-btn" data-class="archer">Archer</div>
      <div class="class-btn" data-class="mage">Mage</div>
    </div>
    <button id="nextButton">Ti·∫øp theo</button>
  </div>
  
  <!-- Name Screen -->
  <div id="nameScreen" class="overlay-screen">
    <h1>Nh·∫≠p t√™n c·ªßa b·∫°n</h1>
    <div id="nameInputs">
      <input type="text" id="playerName" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n" />
    </div>
    <button id="findMatchButton">T√¨m tr·∫≠n</button>
  </div>
  
  <!-- Waiting Screen: Panel s·∫µn s√†ng -->
  <div id="waitingScreen" class="overlay-screen">
    <h1>Ch·ªù tr·∫≠n ƒë·∫•u</h1>
    <div id="readyPanel">
      <div id="readyTimer">30</div>
      <div id="readyContainer">
        <div id="localReady" class="ready-box">B·∫°n: Ch∆∞a s·∫µn s√†ng</div>
        <div id="opponentReady" class="ready-box">ƒê·ªëi th·ªß: Ch∆∞a s·∫µn s√†ng</div>
      </div>
      <button id="readyButton">S·∫µn s√†ng</button>
    </div>
    <div class="spinner" id="waitingSpinner"></div>
  </div>
  
  <!-- Overlay Load Tr·∫≠n -->
  <div id="matchLoadingScreen" class="overlay-screen">
    <div id="topPlayerPanel"></div>
    <div id="bottomPlayerPanel"></div>
    <div id="matchCountdown"></div>
  </div>
  
  <!-- Canvas Game -->
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <!-- Skill Slots cho Local Player -->
  <div id="skillContainer">
    <div class="skill-slot" id="skill-attack">
      <div class="skill-icon">‚öîÔ∏è</div>
      <div class="cooldown-overlay" id="skill-attack-overlay">
        <div class="cooldown-timer" id="skill-attack-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-counter">
      <div class="skill-icon">üõ°Ô∏è</div>
      <div class="cooldown-overlay" id="skill-counter-overlay">
        <div class="cooldown-timer" id="skill-counter-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-special">
      <div class="skill-icon">‚≠ê</div>
      <div class="cooldown-overlay" id="skill-special-overlay">
        <div class="cooldown-timer" id="skill-special-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-ultimate">
      <div class="skill-icon">‚ú¥</div>
      <div class="cooldown-overlay" id="skill-ultimate-overlay">
        <div class="cooldown-timer" id="skill-ultimate-timer"></div>
      </div>
    </div>
  </div>
  
  <script>
    // --- Global Variables & Key State ---
    let player, opponent;
    let localName = "";
    let selectedCharacterLeft = "knight";
    let roomId;
    let keys = {};
    let localReady = false;
    let remoteReady = false;
    
    document.addEventListener("keydown", (e) => { 
      keys[e.key] = true;
      if(socket.connected) socket.emit("player_move", { roomId, playerId: socket.id, key: e.key });
    });
    document.addEventListener("keyup", (e) => { keys[e.key] = false; });
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let score = 0;
    function updateScoreboard() {
      document.getElementById("scoreboard").textContent = `Score: ${score}`;
    }
    function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }
    
    // --- Skill Cooldown & c√°c h√†m game kh√°c (gi·ªØ nguy√™n) ---
    function startSkillCooldown(overlayId, timerId, duration) {
      const overlay = document.getElementById(overlayId);
      const timerElem = document.getElementById(timerId);
      overlay.style.opacity = "1";
      timerElem.style.opacity = "1";
      let startTime = Date.now();
      function update() {
        let elapsed = Date.now() - startTime;
        let remaining = Math.ceil((duration - elapsed) / 1000);
        timerElem.textContent = remaining > 0 ? remaining : "";
        if (elapsed < duration) {
          requestAnimationFrame(update);
        } else {
          overlay.style.opacity = "0";
          timerElem.textContent = "";
        }
      }
      update();
    }
    
    // C√°c h√†m x·ª≠ l√Ω hi·ªáu ·ª©ng, projectiles, zones, v.v. gi·ªØ nguy√™n‚Ä¶
    // (C√°c h√†m updateTrails, updateIceZones, updateThunderZones, updateEffects, drawProjectiles, drawIceZones, drawThunderZones, ... kh√¥ng thay ƒë·ªïi)
    
    // --- L·ªõp Player & gameLoop (gi·ªØ nguy√™n) ---
    class Player {
      constructor(x, y, color, controls, side, characterType) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.controls = controls;
        this.speed = 2;
        this.baseSpeed = this.speed;
        this.size = 15;
        this.characterType = characterType;
        if(characterType === "archer" || characterType === "mage") {
          this.health = 280;
          this.maxHealth = 280;
          this.attack = 30;
          this.baseAttack = this.attack;
          this.attackCooldown = 3000;
          this.baseAttackCooldown = 3000;
          this.ultimateActive = false;
        } else {
          this.health = 300;
          this.maxHealth = 300;
          this.attack = 25;
          this.baseAttack = this.attack;
          this.attackCooldown = 3000;
          this.baseAttackCooldown = 3000;
        }
        this.attacking = false;
        this.lastAttackTime = 0;
        this.attackProcessed = false;
        this.countering = false;
        this.lastCounterTime = 0;
        this.counterCooldown = 5000;
        this.side = side;
        this.name = "";
        this.lastDir = Math.PI/2;
        this.ultimateCooldown = 40000;
        this.lastUltimateTime = 0;
        this.stunned = false;
        this.immobilized = false;
        this.stunStart = null;
        this.critChance = 0.2;
        this.dodgeChance = 0.1;
        this.dodging = false;
        this.dodgeEnd = 0;
        this.effectImmunityEnd = 0;
        this.attackDebuffs = [];
        this.lastSpecialTime = 0;
        this.specialCooldown = 5000;
        if(this.characterType === "knight") {
          this.phantomHealth = 0;
          this.phantomExpire = 0;
          this.immune = false;
          this.buffActive = false;
        }
        if(this.characterType === "mage") {
          this.phantomHealth = 0;
          this.phantomExpire = 0;
          this.waterShieldActive = false;
          this.waterShieldExpire = 0;
          this.attackDebuffActive = false;
          this.attackDebuffExpire = 0;
        }
        this.specialEffect = false;
      }
      drawHealthBar() {
        // (V·∫´n gi·ªØ nguy√™n code v·∫Ω HP)
        let totalWidth = 2 * this.size;
        let x = this.x - totalWidth / 2;
        let y = this.y - this.size - 15;
        if((this.characterType === "knight" || this.characterType === "mage") &&
           this.phantomHealth > 0 && Date.now() < this.phantomExpire) {
          let maxPhantom = (this.characterType === "knight") ? 100 : 20;
          let phantomRatio = this.phantomHealth / maxPhantom;
          let phantomBarHeight = 5;
          let phantomY = y - phantomBarHeight - 2;
          ctx.fillStyle = "white";
          ctx.fillRect(x, phantomY, totalWidth * phantomRatio, phantomBarHeight);
          ctx.strokeStyle = "black";
          ctx.strokeRect(x, phantomY, totalWidth, phantomBarHeight);
        }
        let maxHealth = this.maxHealth;
        let blockCount = Math.ceil(maxHealth / 50);
        let blockWidth = totalWidth / blockCount;
        let remainingHealth = this.health;
        for(let i = 0; i < blockCount; i++){
          let blockValue = 50;
          let fillRatio = Math.min(remainingHealth, blockValue) / blockValue;
          ctx.fillStyle = "red";
          ctx.fillRect(x + i * blockWidth, y, blockWidth, 7);
          ctx.fillStyle = "green";
          ctx.fillRect(x + i * blockWidth, y, blockWidth * fillRatio, 7);
          ctx.strokeStyle = "black";
          ctx.strokeRect(x + i * blockWidth, y, blockWidth, 7);
          remainingHealth -= blockValue;
          if(remainingHealth < 0) remainingHealth = 0;
        }
      }
      drawName() {
        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.name, this.x, this.y - 40);
      }
      draw() {
        // (Gi·ªØ nguy√™n code v·∫Ω player, hi·ªáu ·ª©ng, ...)
        if(this.attackDebuffs.length > 0) {
          ctx.save();
          ctx.fillStyle = "lightblue";
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.size - 25, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        if(this.specialEffect === "knight") {
          ctx.save();
          let pulse = Math.abs(Math.sin(Date.now()/200)) * 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 5 + pulse, 0, Math.PI * 2);
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 3;
          ctx.shadowColor = "yellow";
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.restore();
        } else if(this.specialEffect === "mage") {
          ctx.save();
          let pulse = Math.abs(Math.sin(Date.now()/200)) * 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 5 + pulse, 0, Math.PI * 2);
          ctx.strokeStyle = "skyblue";
          ctx.lineWidth = 3;
          ctx.shadowColor = "skyblue";
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.restore();
        }
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        this.drawHealthBar();
        this.drawName();
        // (Hi·ªáu ·ª©ng stun n·∫øu c√≥)
        if(this.stunned || this.immobilized) { drawStunEffect(this); }
      }
      move(keys) {
        // (Gi·ªØ nguy√™n code x·ª≠ l√Ω di chuy·ªÉn, t·∫•n c√¥ng, counter, ultimate, special, ‚Ä¶)
        let effectiveAttackCooldown = this.baseAttackCooldown;
        this.attackDebuffs = this.attackDebuffs.filter(d => d.expire > Date.now());
        this.attackDebuffs.forEach(d => { effectiveAttackCooldown += d.amount; });
        if(this.characterType === "knight" && this.immune) {
          this.stunned = false;
          this.immobilized = false;
        }
        if(this.characterType === "archer" || this.characterType === "mage") {
          if(this.attackDebuffActive && Date.now() > this.attackDebuffExpire) {
            this.attackCooldown = this.baseAttackCooldown;
            this.attackDebuffActive = false;
          }
        }
        if(!this.immobilized) {
          if(keys[this.controls.left] && this.x > this.size) { this.x -= this.speed; }
          if(keys[this.controls.right] && this.x < canvas.width - this.size) { this.x += this.speed; }
          if(keys[this.controls.up] && this.y > this.size) { this.y -= this.speed; }
          if(keys[this.controls.down] && this.y < canvas.height - this.size) { this.y += this.speed; }
          if(keys[this.controls.left] || keys[this.controls.right] || keys[this.controls.up] || keys[this.controls.down]) {
            this.lastDir = Math.atan2((keys[this.controls.down] ? 1 : 0) - (keys[this.controls.up] ? 1 : 0),
                                       (keys[this.controls.right] ? 1 : 0) - (keys[this.controls.left] ? 1 : 0));
          }
        }
        if(keys[this.controls.attack] && Date.now() - this.lastAttackTime > ((this.ultimateActive && this.characterType==="archer") ? 0 : effectiveAttackCooldown)) {
          this.attacking = true;
          this.attackProcessed = false;
          this.lastAttackTime = Date.now();
          if(this.characterType === "mage") { showFireballEffect(this); }
          else { showAttackEffect(this); }
          startSkillCooldown("skill-attack-overlay", "skill-attack-timer", 3000);
          setTimeout(() => { this.attacking = false; }, 150);
          if(this.characterType === "knight" && this.buffActive) {
            this.speed = this.baseSpeed;
            this.attack = this.baseAttack;
            this.buffActive = false;
          }
        }
        if(keys[this.controls.counter] && Date.now() - this.lastCounterTime > this.counterCooldown) {
          this.countering = true;
          this.lastCounterTime = Date.now();
          showCounterEffect(this);
          startSkillCooldown("skill-counter-overlay", "skill-counter-timer", 3000);
          if(this.characterType === "archer") {
            let bola = {
              type: "bola",
              x: this.x,
              y: this.y,
              dir: this.lastDir,
              speed: 10,
              maxDistance: 300,
              traveled: 0,
              owner: this.side,
              stunDuration: 2000
            };
            projectiles.push(bola);
          } else if(this.characterType === "mage") {
            let iceZone = {
              type: "iceZone",
              x: player.x + 50,
              y: player.y,
              radius: 50,
              damagePerSecond: 5,
              duration: 2000,
              startTime: Date.now(),
              lastUpdate: Date.now(),
              targetSide: player.side
            };
            iceZones.push(iceZone);
            player.immobilized = true;
            setTimeout(() => { player.immobilized = false; }, 2000);
          }
          setTimeout(() => { this.countering = false; }, 1000);
        }
        if(keys[this.controls.ultimate] && Date.now() - this.lastUltimateTime > this.ultimateCooldown) {
          this.lastUltimateTime = Date.now();
          if(this.characterType === "archer") {
            this.ultimateActive = true;
            setTimeout(() => { this.ultimateActive = false; }, 5000);
          } else if(this.characterType === "mage") {
            this.ultimateActive = true;
            this.immobilized = true;
            this.stunned = true;
            let thunderZone = {
              type: "thunderZone",
              x: this.x,
              y: this.y,
              radius: 300,
              duration: 10000,
              startTime: Date.now(),
              lastTick: Date.now(),
              lastStunTime: Date.now(),
              owner: this.side,
              damagePerTick: 0.5 * this.attack,
              tickInterval: 1000
            };
            thunderZones.push(thunderZone);
            setTimeout(() => { this.ultimateActive = false; this.stunned = false; this.immobilized = false; }, 10000);
          } else if(this.characterType === "knight") {
            let healAmount = 50;
            this.health = Math.min(this.health + healAmount, this.maxHealth);
            this.phantomHealth = 100;
            this.phantomExpire = Date.now() + 20000;
            this.immune = true;
            setTimeout(() => { this.immune = false; }, 20000);
            let trail = {
              startX: this.x,
              startY: this.y,
              endX: this.x,
              endY: this.y,
              thickness: 20,
              owner: this.side,
              startTime: Date.now(),
              duration: 10000,
              lastUpdate: Date.now()
            };
            trails.push(trail);
          }
          startSkillCooldown("skill-ultimate-overlay", "skill-ultimate-timer", 40000);
        }
        if(keys["b"] && Date.now() - this.lastSpecialTime >= this.specialCooldown) {
          this.lastSpecialTime = Date.now();
          triggerSpecialZone();
        }
      }
      checkCollision(opponent) { }
    }
    
    // --- Flow: Start -> Class Selection -> Name Input -> T√¨m tr·∫≠n -> Ready Panel ---
    const socket = io("https://two-player-game.onrender.com");
    
    // Khi nh·∫•n "B·∫Øt ƒë·∫ßu" t·ª´ Start Screen
    document.getElementById("startMenuButton").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("characterSelectScreen").style.display = "flex";
    });
    
    // L·∫Øng nghe ch·ªçn class
    const classButtons = document.querySelectorAll(".class-btn");
    classButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        selectedCharacterLeft = btn.getAttribute("data-class");
        classButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
      });
    });
    
    // Khi nh·∫•n "Ti·∫øp theo" ·ªü m√†n h√¨nh ch·ªçn class
    document.getElementById("nextButton").addEventListener("click", () => {
      document.getElementById("characterSelectScreen").style.display = "none";
      document.getElementById("nameScreen").style.display = "flex";
    });
    
    // Khi nh·∫•n "T√¨m tr·∫≠n" ·ªü m√†n h√¨nh nh·∫≠p t√™n
    document.getElementById("findMatchButton").addEventListener("click", () => {
      localName = document.getElementById("playerName").value.trim() || "Player";
      socket.emit("find_match", { name: localName, character: selectedCharacterLeft });
      document.getElementById("nameScreen").style.display = "none";
      document.getElementById("waitingScreen").style.display = "flex";
      document.getElementById("readyPanel").style.display = "block";
    });
    
    // Khi nh·∫•n "S·∫µn s√†ng" trong panel ready
    document.getElementById("readyButton").addEventListener("click", () => {
      if (!localReady) {
        localReady = true;
        document.getElementById("localReady").classList.add("ready");
        document.getElementById("localReady").textContent = "B·∫°n: S·∫µn s√†ng";
        socket.emit("player_ready", { roomId, playerId: socket.id });
      }
    });
    
    socket.on("opponent_ready", () => {
      remoteReady = true;
      document.getElementById("opponentReady").classList.add("ready");
      document.getElementById("opponentReady").textContent = "ƒê·ªëi th·ªß: S·∫µn s√†ng";
    });
    
    // Khi c·∫£ 2 ng∆∞·ªùi ch∆°i s·∫µn s√†ng, server g·ª≠i th√¥ng tin spawn, m√†u v√† ƒë·ªëi th·ªß
    socket.on("both_players_ready", (data) => {
      roomId = data.roomId;
      // B·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c 5 gi√¢y tr∆∞·ªõc khi chuy·ªÉn sang giao di·ªán Load Tr·∫≠n
      let preCountdown = 5;
      document.getElementById("readyTimer").textContent = preCountdown;
      let preInterval = setInterval(() => {
        preCountdown--;
        document.getElementById("readyTimer").textContent = preCountdown;
        if(preCountdown <= 0) {
          clearInterval(preInterval);
          showMatchLoading(data);
        }
      }, 1000);
    });
    
    // H√†m hi·ªÉn th·ªã giao di·ªán Load Tr·∫≠n v·ªõi ƒë·∫øm ng∆∞·ª£c 10 gi√¢y
    function showMatchLoading(data) {
      // ·∫®n m√†n h√¨nh ch·ªù tr·∫≠n
      document.getElementById("waitingScreen").style.display = "none";
      // Hi·ªÉn th·ªã overlay Load Tr·∫≠n
      document.getElementById("matchLoadingScreen").style.display = "flex";
      let localSpawn = data.spawn;
      let localPanelText, opponentPanelText;
      // N·∫øu localSpawn.x == 50 => b·∫°n ·ªü g√≥c tr√™n b√™n tr√°i, ƒë·ªëi th·ªß ·ªü g√≥c d∆∞·ªõi b√™n ph·∫£i
      if(localSpawn.x === 50) {
        localPanelText = `B·∫°n: ${localName} (${selectedCharacterLeft})`;
        opponentPanelText = `ƒê·ªëi th·ªß: ${data.opponent.name} (${data.opponent.character})`;
        document.getElementById("topPlayerPanel").textContent = localPanelText;
        document.getElementById("bottomPlayerPanel").textContent = opponentPanelText;
      } else {
        localPanelText = `B·∫°n: ${localName} (${selectedCharacterLeft})`;
        opponentPanelText = `ƒê·ªëi th·ªß: ${data.opponent.name} (${data.opponent.character})`;
        document.getElementById("topPlayerPanel").textContent = opponentPanelText;
        document.getElementById("bottomPlayerPanel").textContent = localPanelText;
      }
      // B·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c 10 gi√¢y ƒë·ªÉ v√†o tr·∫≠n
      let matchCountdown = 10;
      document.getElementById("matchCountdown").textContent = matchCountdown;
      let matchInterval = setInterval(() => {
        matchCountdown--;
        document.getElementById("matchCountdown").textContent = matchCountdown;
        if(matchCountdown <= 0) {
          clearInterval(matchInterval);
          document.getElementById("matchLoadingScreen").style.display = "none";
          let opponentSpawn = (localSpawn.x === 50) ? {x:750, y:550} : {x:50, y:50};
          createLocalPlayerWithSpawn(localSpawn, data.color);
          createOpponentPlayerWithSpawn(data.opponent, opponentSpawn, (data.color === "blue") ? "red" : "blue");
          gameLoop();
        }
      }, 1000);
    }
    
    socket.on("opponent_left", () => {
      alert("‚ùå ƒê·ªëi th·ªß ƒë√£ r·ªùi kh·ªèi tr·∫≠n ƒë·∫•u!");
      location.reload();
    });
    
    socket.on("update_game", ({ playerId, key }) => {
      let target = (playerId === socket.id) ? player : opponent;
      if (key === "ArrowLeft" || key === "a") target.x -= 5;
      if (key === "ArrowRight" || key === "d") target.x += 5;
      if (key === "ArrowUp" || key === "w") target.y -= 5;
      if (key === "ArrowDown" || key === "s") target.y += 5;
    });
    
    document.getElementById("menuButton").addEventListener("click", () => {
      location.reload();
    });
    
    // --- H√†m t·∫°o ƒë·ªëi t∆∞·ª£ng v·ªõi spawn ---
    function createLocalPlayerWithSpawn(spawn, assignedColor) {
      if(selectedCharacterLeft === "archer") {
        player = new Player(spawn.x, spawn.y, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "archer");
      } else if(selectedCharacterLeft === "mage") {
        player = new Player(spawn.x, spawn.y, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "mage");
      } else {
        player = new Player(spawn.x, spawn.y, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "knight");
      }
      player.name = localName;
    }
    function createOpponentPlayerWithSpawn(oppData, spawn, oppColor) {
      let oppChar = oppData.character || "knight";
      opponent = new Player(spawn.x, spawn.y, oppColor, { left:"ArrowLeft", right:"ArrowRight", up:"ArrowUp", down:"ArrowDown", attack:"Enter", counter:"/", ultimate:"ShiftRight" }, "right", oppChar);
      opponent.name = oppData.name;
    }
    
    function resetRound() {
      if(player) {
        player.health = (player.characterType === "archer" || player.characterType === "mage") ? 280 : 300;
        player.x = 50; player.y = 50;
        player.lastUltimateTime = 0;
      }
      if(opponent) {
        opponent.health = (opponent.characterType === "archer" || opponent.characterType === "mage") ? 280 : 300;
        opponent.x = 750; opponent.y = 550;
        opponent.lastUltimateTime = 0;
      }
      clearAllEffects();
    }
    
    function gameLoop() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(player) {
        player.move(keys);
        player.draw();
      }
      if(opponent) opponent.draw();
      updateEffects();
      updateTrails();
      updateProjectiles();
      updateIceZones();
      updateThunderZones();
      drawProjectiles();
      drawIceZones();
      drawThunderZones();
      if(player && opponent && (player.health <= 0 || opponent.health <= 0)) {
        score++;
        updateScoreboard();
        clearAllEffects();
        resetRound();
      }
      requestAnimationFrame(gameLoop);
    }
    
    // --- S·ª≠a h√†m updateProjectiles ƒë·ªÉ ki·ªÉm tra va ch·∫°m gi·ªØa 2 player ---
    function updateProjectiles() {
      for(let i = projectiles.length - 1; i >= 0; i--) {
        let proj = projectiles[i];
        let dx = proj.speed * Math.cos(proj.dir);
        let dy = proj.speed * Math.sin(proj.dir);
        proj.x += dx;
        proj.y += dy;
        proj.traveled += Math.sqrt(dx*dx + dy*dy);
        // N·∫øu projectile c·ªßa local player th√¨ m·ª•c ti√™u l√† opponent, ng∆∞·ª£c l·∫°i l√† local player
        let target = (proj.owner === player.side) ? opponent : player;
        if(!target) continue;
        let dist = Math.hypot(proj.x - target.x, proj.y - target.y);
        if(dist < target.size) {
          if(Date.now() < target.dodgeEnd || Math.random() < target.dodgeChance) {
            target.dodging = true;
            target.dodgeEnd = Date.now() + 500;
            target.effectImmunityEnd = Date.now() + 750;
            target.stunned = false;
            projectiles.splice(i, 1);
            continue;
          }
          let damage = proj.damage;
          if((proj.type === "bullet" || proj.type === "fireball") && Math.random() < target.critChance) {
            damage *= 1.5;
          }
          target.health = Math.max(0, target.health - damage);
          projectiles.splice(i, 1);
          continue;
        }
        if(proj.traveled >= proj.maxDistance) {
          projectiles.splice(i, 1);
        }
      }
    }
    
    function triggerSpecialZone() {
      startSkillCooldown("skill-special-overlay", "skill-special-timer", 5000);
      if(player) {
        if(player.characterType === "knight") {
          player.speed = player.baseSpeed * 1.3;
          player.attack = player.baseAttack * 1.1;
          player.buffActive = true;
          player.specialEffect = "knight";
          setTimeout(() => { 
              player.buffActive = false; 
              player.specialEffect = false;
              player.speed = player.baseSpeed; 
              player.attack = player.baseAttack;
          }, 5000);
        } else if(player.characterType === "archer") {
          let dash = 200;
          player.x += dash * Math.cos(player.lastDir);
          player.y += dash * Math.sin(player.lastDir);
          player.x = clamp(player.x, player.size, canvas.width - player.size);
          player.y = clamp(player.y, player.size, canvas.height - player.size);
        } else if(player.characterType === "mage") {
          player.waterShieldActive = true;
          player.waterShieldExpire = Date.now() + 3000;
          player.phantomHealth = 20;
          player.specialEffect = "mage";
          setTimeout(() => { 
              player.specialEffect = false;
              player.waterShieldActive = false;
          }, 3000);
        }
      }
    }
  </script>
</body>
</html>
