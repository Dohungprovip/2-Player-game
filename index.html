<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple MOBA</title>
  <!-- S·ª≠ d·ª•ng socket.io t·ª´ server ƒë∆∞·ª£c ph·ª•c v·ª• -->
  <script src="/socket.io/socket.io.js"></script>
  <style>
    /* ---------- Style chung ---------- */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e1e1e, #444);
      color: #fff;
    }
    #scoreboard {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      z-index: 1001;
      background: rgba(0,0,0,0.7);
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.8);
    }
    #menuButton {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1001;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background: linear-gradient(135deg, #555, #777);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      transition: background 0.3s ease;
    }
    #menuButton:hover {
      background: linear-gradient(135deg, #777, #999);
    }
    /* Cooldown timer */
    .cooldown-timer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      opacity: 1 !important;
    }
    /* Canvas */
    canvas {
      display: block;
      margin: 80px auto 20px auto;
      border: 2px solid #fff;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
      background: #444;
    }
    /* C√°c khu v·ª±c trong game (zones, sword-zone,...) */
    .zone, .sword-zone, .u-zone, .special-zone {
      position: absolute;
      width: 80px;
      height: 80px;
      background: #555;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    .sword-zone { overflow: hidden; }
    .sword-zone::before {
      content: "‚öîÔ∏è";
      font-size: 50px;
      text-shadow: 0 0 5px rgba(255,215,0,0.8);
    }
    .counter-zone::before {
      content: "üõ°Ô∏è";
      font-size: 50px;
      text-shadow: 0 0 5px rgba(173,216,230,0.8);
    }
    .u-zone::before {
      content: "üíé";
      font-size: 50px;
      color: #fff;
    }
    #left-sword-zone { left: 20px; bottom: 20px; }
    #left-counter-zone { left: 120px; bottom: 20px; }
    #left-u-zone { left: 220px; bottom: 20px; }
    #right-sword-zone { right: 20px; bottom: 20px; }
    #right-counter-zone { right: 120px; bottom: 20px; }
    #right-u-zone { right: 220px; bottom: 20px; }
    #left-special-zone { left: 20px; bottom: 120px; }
    #right-special-zone { right: 20px; bottom: 120px; }
    .special-zone::before {
      content: "‚òù";
      font-size: 50px;
      text-shadow: 0 0 5px rgba(255,215,0,0.8);
    }
    .cooldown-overlay {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      top: 0;
      left: 0;
      opacity: 0;
      transition: height 0.3s ease, opacity 0.3s ease;
    }
    /* ---------- Overlay chung ---------- */
    .overlay-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.5s ease;
      padding: 20px;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .overlay-screen input,
    .overlay-screen button {
      padding: 10px;
      margin: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
    }
    .overlay-screen input { width: 250px; }
    .overlay-screen button {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      background: linear-gradient(135deg, #555, #777);
      color: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      transition: background 0.3s ease;
    }
    .overlay-screen button:hover {
      background: linear-gradient(135deg, #777, #999);
    }
    /* ---------- C√°c giao di·ªán ri√™ng ---------- */
    /* Start Screen, Character Select, Name Input, Waiting, Match Success, Loading Match */
    #characterSelectScreen,
    #nameScreen,
    #waitingScreen,
    #matchSuccessScreen,
    #loadingMatchScreen {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    /* Character Options */
    #characterOptions {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      width: 90%;
      padding: 10px;
    }
    .class-btn {
      border: 2px solid #fff;
      padding: 10px;
      border-radius: 10px;
      width: 100px;
      height: 100px;
      text-align: center;
      cursor: pointer;
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    .class-btn:hover {
      background-color: gold;
    }
    .class-btn.active {
      border-color: gold;
    }
    /* Name Screen */
    #nameInputs {
      display: flex;
      gap: 20px;
    }
    /* Waiting Screen */
    #readyPanel {
      display: none;
      text-align: center;
      margin-top: 20px;
    }
    #readyTimer {
      font-size: 24px;
      margin-bottom: 20px;
    }
    .ready-box {
      width: 150px;
      padding: 10px;
      margin: 10px auto;
      background-color: gray;
      color: #fff;
      border-radius: 5px;
    }
    .ready-box.ready {
      background-color: limegreen;
    }
    .spinner {
      margin-top: 20px;
    }
    /* Loading Match Screen */
    #loadingContainer {
      display: flex;
      width: 80%;
      justify-content: space-around;
      margin-top: 20px;
    }
    #leftPanel, #rightPanel {
      text-align: center;
    }
    #leftPanel div, #rightPanel div {
      width: 50px;
      height: 50px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <!-- Scoreboard v√† n√∫t Menu -->
  <div id="scoreboard">Score: 0</div>
  <button id="menuButton">Quay l·∫°i menu</button>
  
  <!-- Start Screen -->
  <div id="startScreen" class="overlay-screen" style="display: flex;">
    <h1>Simple MOBA</h1>
    <div class="menu">
      <button id="startMenuButton">B·∫Øt ƒë·∫ßu</button>
      <button id="instructionButton">H∆∞·ªõng d·∫´n</button>
      <button id="infoButton">Th√¥ng tin nh√¢n v·∫≠t</button>
    </div>
  </div>
  
  <!-- Character Selection Screen -->
  <div id="characterSelectScreen" class="overlay-screen">
    <h1>Ch·ªçn Class</h1>
    <div id="characterOptions">
      <div class="class-btn active" data-class="knight">Knight</div>
      <div class="class-btn" data-class="archer">Archer</div>
      <div class="class-btn" data-class="mage">Mage</div>
    </div>
    <button id="nextButton">Ti·∫øp theo</button>
  </div>
  
  <!-- Name Screen -->
  <div id="nameScreen" class="overlay-screen">
    <h1>Nh·∫≠p t√™n c·ªßa b·∫°n</h1>
    <div id="nameInputs">
      <input type="text" id="playerName" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n" />
    </div>
    <button id="findMatchButton">T√¨m tr·∫≠n</button>
  </div>
  
  <!-- Waiting Screen: Panel s·∫µn s√†ng -->
  <div id="waitingScreen" class="overlay-screen">
    <h1>Ch·ªù tr·∫≠n ƒë·∫•u</h1>
    <div id="readyPanel">
      <div id="readyTimer">30</div>
      <div id="readyContainer">
        <div id="localReady" class="ready-box">B·∫°n: Ch∆∞a s·∫µn s√†ng</div>
        <div id="opponentReady" class="ready-box">ƒê·ªëi th·ªß: Ch∆∞a s·∫µn s√†ng</div>
      </div>
      <button id="readyButton">S·∫µn s√†ng</button>
    </div>
    <div class="spinner" id="waitingSpinner"></div>
  </div>
  
  <!-- Match Success Screen -->
  <div id="matchSuccessScreen" class="overlay-screen">
    <h1>Gh√©p tr·∫≠n th√†nh c√¥ng</h1>
    <p>Tr·∫≠n ƒë·∫•u s·∫Ω b·∫Øt ƒë·∫ßu sau <span id="matchSuccessCountdown">5</span> gi√¢y</p>
  </div>
  
  <!-- Loading Match Screen -->
  <div id="loadingMatchScreen" class="overlay-screen">
    <h1>T·∫£i tr·∫≠n</h1>
    <div id="loadingContainer">
      <div id="leftPanel">
        <div id="leftPlayerSquare"></div>
        <p id="leftPlayerName"></p>
        <p id="leftPlayerClass"></p>
      </div>
      <div id="rightPanel">
        <div id="rightPlayerSquare"></div>
        <p id="rightPlayerName"></p>
        <p id="rightPlayerClass"></p>
      </div>
    </div>
  </div>
  
  <!-- Canvas Game -->
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <!-- Skill Slots cho Local Player -->
  <div id="skillContainer">
    <div class="skill-slot" id="skill-attack">
      <div class="skill-icon">‚öîÔ∏è</div>
      <div class="cooldown-overlay" id="skill-attack-overlay">
        <div class="cooldown-timer" id="skill-attack-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-counter">
      <div class="skill-icon">üõ°Ô∏è</div>
      <div class="cooldown-overlay" id="skill-counter-overlay">
        <div class="cooldown-timer" id="skill-counter-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-special">
      <div class="skill-icon">‚≠ê</div>
      <div class="cooldown-overlay" id="skill-special-overlay">
        <div class="cooldown-timer" id="skill-special-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-ultimate">
      <div class="skill-icon">‚ú¥</div>
      <div class="cooldown-overlay" id="skill-ultimate-overlay">
        <div class="cooldown-timer" id="skill-ultimate-timer"></div>
      </div>
    </div>
  </div>
  
  <script>
    // --- Global Variables & Key State ---
    let player, opponent;
    let localName = "";
    let selectedCharacterLeft = "knight";
    let roomId;
    let keys = {};
    let localReady = false;
    let remoteReady = false;
    
    document.addEventListener("keydown", (e) => { 
      keys[e.key] = true;
      if(socket.connected) socket.emit("player_move", { roomId, playerId: socket.id, key: e.key });
    });
    document.addEventListener("keyup", (e) => { keys[e.key] = false; });
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let score = 0;
    function updateScoreboard() {
      document.getElementById("scoreboard").textContent = `Score: ${score}`;
    }
    function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }
    
    // --- Skill Cooldown ---
    function startSkillCooldown(overlayId, timerId, duration) {
      const overlay = document.getElementById(overlayId);
      const timerElem = document.getElementById(timerId);
      overlay.style.opacity = "1";
      timerElem.style.opacity = "1";
      let startTime = Date.now();
      function update() {
        let elapsed = Date.now() - startTime;
        let remaining = Math.ceil((duration - elapsed) / 1000);
        timerElem.textContent = remaining > 0 ? remaining : "";
        if (elapsed < duration) {
          requestAnimationFrame(update);
        } else {
          overlay.style.opacity = "0";
          timerElem.textContent = "";
        }
      }
      update();
    }
    
    // --- C√°c hi·ªáu ·ª©ng, zones, projectiles ---
    const iceZones = [];
    const thunderZones = [];
    const trails = [];
    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = lenSq !== 0 ? dot / lenSq : -1;
      let xx, yy;
      if (param < 0) { xx = x1; yy = y1; }
      else if (param > 1) { xx = x2; yy = y2; }
      else { xx = x1 + param * C; yy = y1 + param * D; }
      const dx = px - xx, dy = py - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function updateTrails() {
      const now = Date.now();
      for (let i = trails.length - 1; i >= 0; i--) {
        const trail = trails[i];
        ctx.save();
        const grad = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
        grad.addColorStop(0, "rgba(255,69,0,0.9)");
        grad.addColorStop(1, "rgba(255,140,0,0.9)");
        ctx.strokeStyle = grad;
        ctx.lineWidth = trail.thickness;
        ctx.shadowColor = "rgba(255,140,0,1)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(trail.startX, trail.startY);
        ctx.lineTo(trail.endX, trail.endY);
        ctx.stroke();
        ctx.restore();
        if (Date.now() - trail.startTime >= trail.duration) { 
          trails.splice(i, 1); 
        } else {
          trail.lastUpdate = Date.now();
        }
      }
    }
    function updateIceZones() {
      const now = Date.now();
      [player, opponent].forEach(target => {
        if(target) {
          iceZones.forEach((zone, index) => {
            if(now - zone.startTime > zone.duration) {
              iceZones.splice(index, 1);
            } else {
              let dt = (now - zone.lastUpdate) / 1000;
              zone.lastUpdate = now;
              let dist = Math.hypot(target.x - zone.x, target.y - zone.y);
              if(dist <= zone.radius) {
                target.health = Math.max(0, target.health - zone.damagePerSecond * dt);
                if(target.health <= 0) {
                  score++;
                  updateScoreboard();
                  clearAllEffects();
                  resetRound();
                }
              }
            }
          });
        }
      });
    }
    function drawIceZones() {
      iceZones.forEach(zone => {
        ctx.save();
        let grad = ctx.createRadialGradient(zone.x, zone.y, zone.radius * 0.2, zone.x, zone.y, zone.radius);
        grad.addColorStop(0, "rgba(173,216,230,0.8)");
        grad.addColorStop(1, "rgba(0,191,255,0.2)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function updateThunderZones() {
      const now = Date.now();
      [player, opponent].forEach(target => {
        if(target) {
          thunderZones.forEach((zone, index) => {
            if(now - zone.startTime > zone.duration) {
              thunderZones.splice(index, 1);
            } else {
              if(now - zone.lastTick >= zone.tickInterval) {
                zone.lastTick = now;
                let dist = Math.hypot(target.x - zone.x, target.y - zone.y);
                if(dist <= zone.radius) {
                  target.health = Math.max(0, target.health - zone.damagePerTick);
                  if(now - zone.lastStunTime >= 2000) {
                    zone.lastStunTime = now;
                    target.stunned = true;
                    setTimeout(() => { target.stunned = false; }, 1000);
                  }
                  if(target.health <= 0) {
                    score++;
                    updateScoreboard();
                    clearAllEffects();
                    resetRound();
                  }
                }
              }
            }
          });
        }
      });
    }
    function drawThunderZones() {
      thunderZones.forEach(zone => {
        ctx.save();
        let alpha = 0.5 + 0.5 * Math.sin(Date.now()/200);
        ctx.strokeStyle = `rgba(128,0,128,${alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      });
    }
    const effects = [];
    class Effect {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.startTime = Date.now();
        this.duration = type === "attack" ? 150 : 500;
      }
      update(ctx, currentTime) {
        let elapsed = currentTime - this.startTime;
        let progress = elapsed / this.duration;
        if(progress > 1) return false;
        ctx.save();
        if(this.type === "attack") {
          const radius = 40;
          let alpha = 1 - progress;
          ctx.fillStyle = `rgba(255,100,100,${alpha})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, radius, 0, Math.PI*2);
          ctx.closePath();
          ctx.fill();
        } else if(this.type === "counter") {
          const radius = 25;
          let alpha = 1 - progress;
          ctx.strokeStyle = `rgba(255,215,0,${alpha})`;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.arc(this.x, this.y, radius, 0, Math.PI*2);
          ctx.stroke();
        }
        ctx.restore();
        return true;
      }
    }
    function updateEffects() {
      const now = Date.now();
      for(let i = effects.length - 1; i >= 0; i--) {
        if(!effects[i].update(ctx, now)) { effects.splice(i, 1); }
      }
    }
    function showAttackEffect(player) {
      if(player.characterType === "knight") {
        effects.push(new Effect(player.x, player.y, "attack"));
        if(player.buffActive) {
          player.speed = player.baseSpeed;
          player.attack = player.baseAttack;
          player.buffActive = false;
        }
      } else if(player.characterType === "archer") {
        showBulletEffect(player);
      }
    }
    function showCounterEffect(player) {
      effects.push(new Effect(player.x, player.y, "counter"));
    }
    function showFireballEffect(player) {
      let fireball = {
        type: "fireball",
        x: player.x,
        y: player.y,
        dir: player.lastDir,
        speed: 15,
        maxDistance: 500,
        traveled: 0,
        owner: player.side,
        damage: player.attack
      };
      projectiles.push(fireball);
    }
    function showBulletEffect(player) {
      let bullet = {
        type: "bullet",
        x: player.x,
        y: player.y,
        dir: player.lastDir,
        speed: 15,
        maxDistance: 1000,
        traveled: 0,
        owner: player.side,
        damage: player.attack
      };
      projectiles.push(bullet);
    }
    const projectiles = [];
    function updateProjectiles() {
      for(let i = projectiles.length - 1; i >= 0; i--) {
        let proj = projectiles[i];
        let dx = proj.speed * Math.cos(proj.dir);
        let dy = proj.speed * Math.sin(proj.dir);
        proj.x += dx;
        proj.y += dy;
        proj.traveled += Math.sqrt(dx*dx + dy*dy);
        let target = (proj.owner === player.side) ? opponent : player;
        if(!target) continue;
        let dist = Math.hypot(proj.x - target.x, proj.y - target.y);
        if(dist < target.size) {
          if(Date.now() < target.dodgeEnd || Math.random() < target.dodgeChance) {
            target.dodging = true;
            target.dodgeEnd = Date.now() + 500;
            target.effectImmunityEnd = Date.now() + 750;
            target.stunned = false;
            projectiles.splice(i, 1);
            continue;
          }
          let damage = proj.damage;
          if((proj.type === "bullet" || proj.type === "fireball") && Math.random() < target.critChance) {
            damage *= 1.5;
          }
          target.health = Math.max(0, target.health - damage);
          projectiles.splice(i, 1);
          continue;
        }
        if(proj.traveled >= proj.maxDistance) {
          projectiles.splice(i, 1);
        }
      }
    }
    function drawProjectiles() {
      projectiles.forEach(proj => {
        ctx.save();
        if(proj.type === "bullet") {
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 6, 0, Math.PI*2);
          ctx.fill();
        } else if(proj.type === "fireball") {
          let grad = ctx.createRadialGradient(proj.x, proj.y, 2, proj.x, proj.y, 10);
          grad.addColorStop(0, "white");
          grad.addColorStop(0.5, "orange");
          grad.addColorStop(1, "red");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 10, 0, Math.PI*2);
          ctx.fill();
        } else if(proj.type === "bola") {
          ctx.fillStyle = "orange";
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 8, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      });
    }
    function drawStunEffect(target) {
      let time = Date.now();
      let alpha = 0.5 + 0.5 * Math.sin(time/200);
      ctx.save();
      ctx.font = "24px Arial";
      ctx.fillStyle = `rgba(255,255,0,${alpha})`;
      ctx.textAlign = "center";
      ctx.fillText("‚õìÔ∏è", target.x, target.y - target.size - 10);
      ctx.restore();
    }
    function clearAllEffects() {
      trails.length = 0;
      iceZones.length = 0;
      thunderZones.length = 0;
      effects.length = 0;
      projectiles.length = 0;
      if(player) { player.stunned = false; player.immobilized = false; }
      if(opponent) { opponent.stunned = false; opponent.immobilized = false; }
    }
    // --- L·ªõp Player ---
    class Player {
      constructor(x, y, color, controls, side, characterType) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.controls = controls;
        this.speed = 2;
        this.baseSpeed = this.speed;
        this.size = 15;
        this.characterType = characterType;
        if(characterType === "archer" || characterType === "mage") {
          this.health = 280;
          this.maxHealth = 280;
          this.attack = 30;
          this.baseAttack = this.attack;
          this.attackCooldown = 3000;
          this.baseAttackCooldown = 3000;
          this.ultimateActive = false;
        } else {
          this.health = 300;
          this.maxHealth = 300;
          this.attack = 25;
          this.baseAttack = this.attack;
          this.attackCooldown = 3000;
          this.baseAttackCooldown = 3000;
        }
        this.attacking = false;
        this.lastAttackTime = 0;
        this.attackProcessed = false;
        this.countering = false;
        this.lastCounterTime = 0;
        this.counterCooldown = 5000;
        this.side = side;
        this.name = "";
        this.lastDir = Math.PI/2;
        this.ultimateCooldown = 40000;
        this.lastUltimateTime = 0;
        this.stunned = false;
        this.immobilized = false;
        this.stunStart = null;
        this.critChance = 0.2;
        this.dodgeChance = 0.1;
        this.dodging = false;
        this.dodgeEnd = 0;
        this.effectImmunityEnd = 0;
        this.attackDebuffs = [];
        this.lastSpecialTime = 0;
        this.specialCooldown = 5000;
        if(this.characterType === "knight") {
          this.phantomHealth = 0;
          this.phantomExpire = 0;
          this.immune = false;
          this.buffActive = false;
        }
        if(this.characterType === "mage") {
          this.phantomHealth = 0;
          this.phantomExpire = 0;
          this.waterShieldActive = false;
          this.waterShieldExpire = 0;
          this.attackDebuffActive = false;
          this.attackDebuffExpire = 0;
        }
        this.specialEffect = false;
      }
      drawHealthBar() {
        let totalWidth = 2 * this.size;
        let x = this.x - totalWidth / 2;
        let y = this.y - this.size - 15;
        if((this.characterType === "knight" || this.characterType === "mage") &&
           this.phantomHealth > 0 && Date.now() < this.phantomExpire) {
          let maxPhantom = (this.characterType === "knight") ? 100 : 20;
          let phantomRatio = this.phantomHealth / maxPhantom;
          let phantomBarHeight = 5;
          let phantomY = y - phantomBarHeight - 2;
          ctx.fillStyle = "white";
          ctx.fillRect(x, phantomY, totalWidth * phantomRatio, phantomBarHeight);
          ctx.strokeStyle = "black";
          ctx.strokeRect(x, phantomY, totalWidth, phantomBarHeight);
        }
        let maxHealth = this.maxHealth;
        let blockCount = Math.ceil(maxHealth / 50);
        let blockWidth = totalWidth / blockCount;
        let remainingHealth = this.health;
        for(let i = 0; i < blockCount; i++){
          let blockValue = 50;
          let fillRatio = Math.min(remainingHealth, blockValue) / blockValue;
          ctx.fillStyle = "red";
          ctx.fillRect(x + i * blockWidth, y, blockWidth, 7);
          ctx.fillStyle = "green";
          ctx.fillRect(x + i * blockWidth, y, blockWidth * fillRatio, 7);
          ctx.strokeStyle = "black";
          ctx.strokeRect(x + i * blockWidth, y, blockWidth, 7);
          remainingHealth -= blockValue;
          if(remainingHealth < 0) remainingHealth = 0;
        }
      }
      drawName() {
        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.name, this.x, this.y - 40);
      }
      draw() {
        if(this.attackDebuffs.length > 0) {
          ctx.save();
          ctx.fillStyle = "lightblue";
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.size - 25, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        if(this.specialEffect === "knight") {
          ctx.save();
          let pulse = Math.abs(Math.sin(Date.now()/200)) * 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 5 + pulse, 0, Math.PI * 2);
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 3;
          ctx.shadowColor = "yellow";
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.restore();
        } else if(this.specialEffect === "mage") {
          ctx.save();
          let pulse = Math.abs(Math.sin(Date.now()/200)) * 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 5 + pulse, 0, Math.PI * 2);
          ctx.strokeStyle = "skyblue";
          ctx.lineWidth = 3;
          ctx.shadowColor = "skyblue";
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.restore();
        }
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        this.drawHealthBar();
        this.drawName();
        if(this.stunned || this.immobilized) { drawStunEffect(this); }
      }
      move(keys) {
        let effectiveAttackCooldown = this.baseAttackCooldown;
        this.attackDebuffs = this.attackDebuffs.filter(d => d.expire > Date.now());
        this.attackDebuffs.forEach(d => { effectiveAttackCooldown += d.amount; });
        if(this.characterType === "knight" && this.immune) {
          this.stunned = false;
          this.immobilized = false;
        }
        if(this.characterType === "archer" || this.characterType === "mage") {
          if(this.attackDebuffActive && Date.now() > this.attackDebuffExpire) {
            this.attackCooldown = this.baseAttackCooldown;
            this.attackDebuffActive = false;
          }
        }
        if(!this.immobilized) {
          if(keys[this.controls.left] && this.x > this.size) { this.x -= this.speed; }
          if(keys[this.controls.right] && this.x < canvas.width - this.size) { this.x += this.speed; }
          if(keys[this.controls.up] && this.y > this.size) { this.y -= this.speed; }
          if(keys[this.controls.down] && this.y < canvas.height - this.size) { this.y += this.speed; }
          if(keys[this.controls.left] || keys[this.controls.right] || keys[this.controls.up] || keys[this.controls.down]) {
            this.lastDir = Math.atan2((keys[this.controls.down] ? 1 : 0) - (keys[this.controls.up] ? 1 : 0),
                                       (keys[this.controls.right] ? 1 : 0) - (keys[this.controls.left] ? 1 : 0));
          }
        }
        if(keys[this.controls.attack] && Date.now() - this.lastAttackTime > ((this.ultimateActive && this.characterType==="archer") ? 0 : effectiveAttackCooldown)) {
          this.attacking = true;
          this.attackProcessed = false;
          this.lastAttackTime = Date.now();
          if(this.characterType === "mage") { showFireballEffect(this); }
          else { showAttackEffect(this); }
          startSkillCooldown("skill-attack-overlay", "skill-attack-timer", 3000);
          setTimeout(() => { this.attacking = false; }, 150);
          if(this.characterType === "knight" && this.buffActive) {
            this.speed = this.baseSpeed;
            this.attack = this.baseAttack;
            this.buffActive = false;
          }
        }
        if(keys[this.controls.counter] && Date.now() - this.lastCounterTime > this.counterCooldown) {
          this.countering = true;
          this.lastCounterTime = Date.now();
          showCounterEffect(this);
          startSkillCooldown("skill-counter-overlay", "skill-counter-timer", 3000);
          if(this.characterType === "archer") {
            let bola = {
              type: "bola",
              x: this.x,
              y: this.y,
              dir: this.lastDir,
              speed: 10,
              maxDistance: 300,
              traveled: 0,
              owner: this.side,
              stunDuration: 2000
            };
            projectiles.push(bola);
          } else if(this.characterType === "mage") {
            let iceZone = {
              type: "iceZone",
              x: player.x + 50,
              y: player.y,
              radius: 50,
              damagePerSecond: 5,
              duration: 2000,
              startTime: Date.now(),
              lastUpdate: Date.now(),
              targetSide: player.side
            };
            iceZones.push(iceZone);
            player.immobilized = true;
            setTimeout(() => { player.immobilized = false; }, 2000);
          }
          setTimeout(() => { this.countering = false; }, 1000);
        }
        if(keys[this.controls.ultimate] && Date.now() - this.lastUltimateTime > this.ultimateCooldown) {
          this.lastUltimateTime = Date.now();
          if(this.characterType === "archer") {
            this.ultimateActive = true;
            setTimeout(() => { this.ultimateActive = false; }, 5000);
          } else if(this.characterType === "mage") {
            this.ultimateActive = true;
            this.immobilized = true;
            this.stunned = true;
            let thunderZone = {
              type: "thunderZone",
              x: this.x,
              y: this.y,
              radius: 300,
              duration: 10000,
              startTime: Date.now(),
              lastTick: Date.now(),
              lastStunTime: Date.now(),
              owner: this.side,
              damagePerTick: 0.5 * this.attack,
              tickInterval: 1000
            };
            thunderZones.push(thunderZone);
            setTimeout(() => { this.ultimateActive = false; this.stunned = false; this.immobilized = false; }, 10000);
          } else if(this.characterType === "knight") {
            let healAmount = 50;
            this.health = Math.min(this.health + healAmount, this.maxHealth);
            this.phantomHealth = 100;
            this.phantomExpire = Date.now() + 20000;
            this.immune = true;
            setTimeout(() => { this.immune = false; }, 20000);
            let trail = {
              startX: this.x,
              startY: this.y,
              endX: this.x,
              endY: this.y,
              thickness: 20,
              owner: this.side,
              startTime: Date.now(),
              duration: 10000,
              lastUpdate: Date.now()
            };
            trails.push(trail);
          }
          startSkillCooldown("skill-ultimate-overlay", "skill-ultimate-timer", 40000);
        }
        if(keys["b"] && Date.now() - this.lastSpecialTime >= this.specialCooldown) {
          this.lastSpecialTime = Date.now();
          triggerSpecialZone();
        }
      }
      checkCollision(opponent) { }
    }
    
    // --- K·∫øt n·ªëi Socket qua host hi·ªán h√†nh ---
    const socket = io();
    
    // --- Flow: Start -> Ch·ªçn Class -> Nh·∫≠p T√™n -> T√¨m Tr·∫≠n -> Ch·ªù Tr·∫≠n ---
    document.getElementById("startMenuButton").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("characterSelectScreen").style.display = "flex";
    });
    
    const classButtons = document.querySelectorAll(".class-btn");
    classButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        selectedCharacterLeft = btn.getAttribute("data-class");
        classButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
      });
    });
    
    document.getElementById("nextButton").addEventListener("click", () => {
      document.getElementById("characterSelectScreen").style.display = "none";
      document.getElementById("nameScreen").style.display = "flex";
    });
    
    document.getElementById("findMatchButton").addEventListener("click", () => {
      localName = document.getElementById("playerName").value.trim() || "Player";
      socket.emit("find_match", { name: localName, character: selectedCharacterLeft });
      document.getElementById("nameScreen").style.display = "none";
      document.getElementById("waitingScreen").style.display = "flex";
    });
    
    document.getElementById("readyButton").addEventListener("click", () => {
      if (!localReady) {
        localReady = true;
        document.getElementById("localReady").classList.add("ready");
        document.getElementById("localReady").textContent = "B·∫°n: S·∫µn s√†ng";
        socket.emit("player_ready", { roomId, playerId: socket.id });
      }
    });
    
    socket.on("opponent_ready", () => {
      remoteReady = true;
      document.getElementById("opponentReady").classList.add("ready");
      document.getElementById("opponentReady").textContent = "ƒê·ªëi th·ªß: S·∫µn s√†ng";
    });
    
    // --- X·ª≠ l√Ω c√°c event t·ª´ server ---
    // Khi c·∫£ 2 ƒë√£ s·∫µn s√†ng, server g·ª≠i event "match_success" v·ªõi ƒë·∫øm ng∆∞·ª£c 5 gi√¢y
    socket.on("match_success", (data) => {
      roomId = data.roomId;
      document.getElementById("waitingScreen").style.display = "none";
      const matchSuccessScreen = document.getElementById("matchSuccessScreen");
      matchSuccessScreen.style.display = "flex";
      let countdown = data.countdown;
      document.getElementById("matchSuccessCountdown").textContent = countdown;
      const interval = setInterval(() => {
        countdown--;
        document.getElementById("matchSuccessCountdown").textContent = countdown;
        if (countdown <= 0) {
          clearInterval(interval);
          matchSuccessScreen.style.display = "none";
        }
      }, 1000);
    });
    
    // Sau 5 gi√¢y, server g·ª≠i event "load_match" v·ªõi th√¥ng tin spawn v√† ƒë·ªëi th·ªß (v·ªõi 2 panel: b√™n tr√°i & b√™n ph·∫£i)
    socket.on("load_match", (data) => {
      roomId = data.roomId;
      const localSpawn = data.spawn;
      const localColor = data.color;
      const opponentData = data.opponent;
      const loadingScreen = document.getElementById("loadingMatchScreen");
      loadingScreen.style.display = "flex";
      
      if(localSpawn.x === 50 && localSpawn.y === 50) {
        // N·∫øu local spawn ·ªü g√≥c tr√™n b√™n tr√°i: hi·ªÉn th·ªã local ·ªü panel b√™n ph·∫£i
        document.getElementById("rightPlayerSquare").style.backgroundColor = localColor;
        document.getElementById("rightPlayerName").textContent = localName;
        document.getElementById("rightPlayerClass").textContent = selectedCharacterLeft;
        // ƒê·ªëi th·ªß hi·ªÉn th·ªã ·ªü panel b√™n tr√°i
        document.getElementById("leftPlayerSquare").style.backgroundColor = opponentData.character;
        document.getElementById("leftPlayerName").textContent = opponentData.name;
        document.getElementById("leftPlayerClass").textContent = opponentData.character;
      } else {
        // Ng∆∞·ª£c l·∫°i: local hi·ªÉn th·ªã ·ªü panel b√™n tr√°i
        document.getElementById("leftPlayerSquare").style.backgroundColor = localColor;
        document.getElementById("leftPlayerName").textContent = localName;
        document.getElementById("leftPlayerClass").textContent = selectedCharacterLeft;
        // ƒê·ªëi th·ªß hi·ªÉn th·ªã ·ªü panel b√™n ph·∫£i
        document.getElementById("rightPlayerSquare").style.backgroundColor = opponentData.character;
        document.getElementById("rightPlayerName").textContent = opponentData.name;
        document.getElementById("rightPlayerClass").textContent = opponentData.character;
      }
      
      // Sau 10 gi√¢y, loading screen s·∫Ω ·∫©n (server s·∫Ω g·ª≠i "start_game")
      setTimeout(() => {
        loadingScreen.style.display = "none";
      }, 10000);
    });
    
    // Khi nh·∫≠n event "start_game", ·∫©n c√°c overlay v√† b·∫Øt ƒë·∫ßu game (canvas)
    socket.on("start_game", () => {
      document.getElementById("matchSuccessScreen").style.display = "none";
      document.getElementById("loadingMatchScreen").style.display = "none";
      document.getElementById("waitingScreen").style.display = "none";
      gameLoop();
    });
    
    socket.on("update_game", ({ playerId, key }) => {
      let target = (playerId === socket.id) ? player : opponent;
      if (key === "ArrowLeft" || key === "a") target.x -= 5;
      if (key === "ArrowRight" || key === "d") target.x += 5;
      if (key === "ArrowUp" || key === "w") target.y -= 5;
      if (key === "ArrowDown" || key === "s") target.y += 5;
    });
    
    document.getElementById("menuButton").addEventListener("click", () => {
      location.reload();
    });
    
    // --- H√†m t·∫°o ƒë·ªëi t∆∞·ª£ng player & gameLoop ---
    function createLocalPlayerWithSpawn(spawn, assignedColor) {
      if(selectedCharacterLeft === "archer") {
        player = new Player(spawn.x, spawn.y, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "archer");
      } else if(selectedCharacterLeft === "mage") {
        player = new Player(spawn.x, spawn.y, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "mage");
      } else {
        player = new Player(spawn.x, spawn.y, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "knight");
      }
      player.name = localName;
    }
    function createOpponentPlayerWithSpawn(oppData, spawn, oppColor) {
      let oppChar = oppData.character || "knight";
      opponent = new Player(spawn.x, spawn.y, oppColor, { left:"ArrowLeft", right:"ArrowRight", up:"ArrowUp", down:"ArrowDown", attack:"Enter", counter:"/", ultimate:"ShiftRight" }, "right", oppChar);
      opponent.name = oppData.name;
    }
    function resetRound() {
      if(player) {
        player.health = (player.characterType === "archer" || player.characterType === "mage") ? 280 : 300;
        player.x = 50; player.y = 50;
        player.lastUltimateTime = 0;
      }
      if(opponent) {
        opponent.health = (opponent.characterType === "archer" || opponent.characterType === "mage") ? 280 : 300;
        opponent.x = 750; opponent.y = 550;
        opponent.lastUltimateTime = 0;
      }
      clearAllEffects();
    }
    function gameLoop() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(player) {
        player.move(keys);
        player.draw();
      }
      if(opponent) opponent.draw();
      updateEffects();
      updateTrails();
      updateProjectiles();
      updateIceZones();
      updateThunderZones();
      drawProjectiles();
      drawIceZones();
      drawThunderZones();
      if(player && opponent && (player.health <= 0 || opponent.health <= 0)) {
        score++;
        updateScoreboard();
        clearAllEffects();
        resetRound();
      }
      requestAnimationFrame(gameLoop);
    }
    
    // --- H√†m Special Zone ---
    function triggerSpecialZone() {
      startSkillCooldown("skill-special-overlay", "skill-special-timer", 5000);
      if(player) {
        if(player.characterType === "knight") {
          player.speed = player.baseSpeed * 1.3;
          player.attack = player.baseAttack * 1.1;
          player.buffActive = true;
          player.specialEffect = "knight";
          setTimeout(() => { 
              player.buffActive = false; 
              player.specialEffect = false;
              player.speed = player.baseSpeed; 
              player.attack = player.baseAttack;
          }, 5000);
        } else if(player.characterType === "archer") {
          let dash = 200;
          player.x += dash * Math.cos(player.lastDir);
          player.y += dash * Math.sin(player.lastDir);
          player.x = clamp(player.x, player.size, canvas.width - player.size);
          player.y = clamp(player.y, player.size, canvas.height - player.size);
        } else if(player.characterType === "mage") {
          player.waterShieldActive = true;
          player.waterShieldExpire = Date.now() + 3000;
          player.phantomHealth = 20;
          player.specialEffect = "mage";
          setTimeout(() => { 
              player.specialEffect = false;
              player.waterShieldActive = false;
          }, 3000);
        }
      }
    }
  </script>
</body>
</html>
