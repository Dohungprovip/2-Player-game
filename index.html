<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple MOBA</title>
  <style>
    /* Global Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #1e1e1e, #444);
      color: #fff;
    }
    /* Scoreboard */
    #scoreboard {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      z-index: 1001;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.8);
    }
    /* Canvas */
    canvas {
      display: block;
      margin: 80px auto 20px auto;
      border: 2px solid #fff;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
      background: #444;
    }
    /* Zone Styles */
    .zone, .sword-zone, .u-zone {
      position: absolute;
      width: 80px;
      height: 80px;
      background-color: #555;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    .sword-zone { overflow: hidden; }
    .sword-zone::before {
      content: "‚öîÔ∏è";
      font-size: 50px;
      text-shadow: 0 0 5px rgba(255,215,0,0.8);
    }
    .counter-zone::before {
      content: "üõ°Ô∏è";
      font-size: 50px;
      text-shadow: 0 0 5px rgba(173,216,230,0.8);
    }
    .u-zone::before {
      content: "üíé";
      font-size: 50px;
      color: #fff;
    }
    /* Positioning */
    #left-sword-zone { left: 20px; bottom: 20px; }
    #left-counter-zone { left: 120px; bottom: 20px; }
    #left-u-zone { left: 220px; bottom: 20px; }
    #right-sword-zone { right: 20px; bottom: 20px; }
    #right-counter-zone { right: 120px; bottom: 20px; }
    #right-u-zone { right: 220px; bottom: 20px; }
    /* Cooldown Overlay & Timer (d√πng chung) */
    .cooldown-overlay {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      top: 0;
      left: 0;
      opacity: 0;
      transition: height 0.3s ease, opacity 0.3s ease;
    }
    .cooldown-timer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      font-weight: bold;
      color: #fff;
    }
    /* Overlay Screens */
    .overlay-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.5s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .overlay-screen input,
    .overlay-screen button {
      padding: 10px;
      margin: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
    }
    .overlay-screen input { width: 250px; }
    .overlay-screen button {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      background: linear-gradient(135deg, #555, #777);
      color: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      transition: background 0.3s ease;
    }
    .overlay-screen button:hover {
      background: linear-gradient(135deg, #777, #999);
    }
    .character-option {
      border: 2px solid #fff;
      padding: 20px;
      border-radius: 10px;
      margin: 10px;
      width: 200px;
      text-align: center;
      transition: border-color 0.3s ease;
      cursor: pointer;
    }
    .character-option.selected {
      border-color: gold;
    }
    /* Style cho kh·ªëi ch·ªçn nh√¢n v·∫≠t hai b√™n */
    #characterOptions {
      display: flex;
      justify-content: space-around;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="scoreboard">Blue: 0 | Red: 0</div>
  
  <!-- Start Screen -->
  <div id="startScreen" class="overlay-screen">
    <h1>Enter Player Names</h1>
    <input type="text" id="player1Name" placeholder="Player 1 Name" />
    <input type="text" id="player2Name" placeholder="Player 2 Name" />
    <button id="startButton">Continue</button>
  </div>
  
  <!-- Character Selection Screen (Knight, Archer, Mage) -->
  <div id="characterSelectScreen" class="overlay-screen" style="display:none;">
    <h1>Select Characters</h1>
    <div id="characterOptions">
      <div id="left-character-select">
        <h2>Player 1 - Select Class</h2>
        <div class="character-option selected" data-character="knight">
          <h3>Knight</h3>
        </div>
        <div class="character-option" data-character="archer">
          <h3>Archer</h3>
        </div>
        <div class="character-option" data-character="mage">
          <h3>Mage</h3>
        </div>
      </div>
      <div id="right-character-select">
        <h2>Player 2 - Select Class</h2>
        <div class="character-option selected" data-character="knight">
          <h3>Knight</h3>
        </div>
        <div class="character-option" data-character="archer">
          <h3>Archer</h3>
        </div>
        <div class="character-option" data-character="mage">
          <h3>Mage</h3>
        </div>
      </div>
    </div>
    <button id="confirmCharacterButton">Start Battle</button>
  </div>
  
  <!-- Skill Zones (Cooldown Overlays) -->
  <div id="left-sword-zone" class="sword-zone">
    <div class="cooldown-overlay" id="left-cooldown">
      <span class="cooldown-timer" id="left-cooldown-timer"></span>
    </div>
  </div>
  <div id="right-sword-zone" class="sword-zone">
    <div class="cooldown-overlay" id="right-cooldown">
      <span class="cooldown-timer" id="right-cooldown-timer"></span>
    </div>
  </div>
  <div id="left-counter-zone" class="zone counter-zone">
    <div class="cooldown-overlay" id="left-counter-cooldown">
      <span class="cooldown-timer" id="left-counter-timer"></span>
    </div>
  </div>
  <div id="right-counter-zone" class="zone counter-zone">
    <div class="cooldown-overlay" id="right-counter-cooldown">
      <span class="cooldown-timer" id="right-counter-timer"></span>
    </div>
  </div>
  <div id="left-u-zone" class="zone u-zone">
    <div class="cooldown-overlay" id="left-ultimate-cooldown">
      <span class="cooldown-timer" id="left-ultimate-timer"></span>
    </div>
  </div>
  <div id="right-u-zone" class="zone u-zone">
    <div class="cooldown-overlay" id="right-ultimate-cooldown">
      <span class="cooldown-timer" id="right-ultimate-timer"></span>
    </div>
  </div>
  
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <script>
    // Global variables and event listeners
    const keys = {};
    window.addEventListener("keydown", e => { keys[e.key] = true; keys[e.code] = true; });
    window.addEventListener("keyup", e => { keys[e.key] = false; keys[e.code] = false; });
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let scoreBlue = 0, scoreRed = 0;
    function updateScoreboard() {
      document.getElementById("scoreboard").textContent = `Blue: ${scoreBlue} | Red: ${scoreRed}`;
    }
    function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }
    
    // --- Function chung cho hi·ªáu ·ª©ng h·ªìi chi√™u ---
    function startCooldownEffect(overlayId, timerId, duration) {
      const overlay = document.getElementById(overlayId);
      const timerElem = document.getElementById(timerId);
      overlay.style.opacity = "1";
      overlay.style.height = "100%";
      let startTime = Date.now();
      function update() {
        let elapsed = Date.now() - startTime;
        let progress = elapsed / duration;
        let remaining = Math.ceil((duration - elapsed) / 1000);
        timerElem.textContent = remaining > 0 ? remaining : "";
        if (progress < 1) {
          overlay.style.height = `${(1 - progress) * 100}%`;
          overlay.style.opacity = `${1 - progress}`;
          requestAnimationFrame(update);
        } else {
          overlay.style.height = "0%";
          overlay.style.opacity = "0";
          timerElem.textContent = "";
        }
      }
      update();
    }
    
    // --- Global arrays cho IceZone v√† ThunderZone ---
    const iceZones = [];
    const thunderZones = [];
    
    // --- Trails for Ultimate (fire trail effect) ---
    const trails = [];
    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = lenSq !== 0 ? dot / lenSq : -1;
      let xx, yy;
      if (param < 0) { xx = x1; yy = y1; }
      else if (param > 1) { xx = x2; yy = y2; }
      else { xx = x1 + param * C; yy = y1 + param * D; }
      const dx = px - xx, dy = py - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function updateTrails() {
      const now = Date.now();
      for (let i = trails.length - 1; i >= 0; i--) {
        const trail = trails[i];
        ctx.save();
        const grad = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
        grad.addColorStop(0, "rgba(255,69,0,0.9)");
        grad.addColorStop(1, "rgba(255,140,0,0.9)");
        ctx.strokeStyle = grad;
        ctx.lineWidth = trail.thickness;
        ctx.shadowColor = "rgba(255,140,0,1)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(trail.startX, trail.startY);
        ctx.lineTo(trail.endX, trail.endY);
        ctx.stroke();
        ctx.restore();
        if (now - trail.startTime < trail.duration) {
          const dt = (now - trail.lastUpdate) / 1000;
          trail.lastUpdate = now;
          [player1, player2].forEach(player => {
            if (player.side !== trail.owner) {
              const dist = pointToSegmentDistance(player.x, player.y, trail.startX, trail.startY, trail.endX, trail.endY);
              if (dist < trail.thickness / 2) {
                player.health = Math.max(0, player.health - 5 * dt);
                if (player.health <= 0) {
                  if (player.side === "left") { scoreRed++; } else { scoreBlue++; }
                  updateScoreboard();
                  clearAllEffects();
                  resetRound();
                }
              }
            }
          });
        } else { trails.splice(i, 1); }
      }
    }
    
    // --- Update and Draw Ice Zones (Mage Counter) ---
    function updateIceZones() {
      const now = Date.now();
      for (let i = iceZones.length - 1; i >= 0; i--) {
        let zone = iceZones[i];
        if(now - zone.startTime > zone.duration) {
          iceZones.splice(i, 1);
        } else {
          let dt = (now - zone.lastUpdate) / 1000;
          zone.lastUpdate = now;
          let target = zone.targetSide === "left" ? player1 : player2;
          if(Date.now() < target.effectImmunityEnd) return; // immune v·ªõi hi·ªáu ·ª©ng m·ªõi
          let dist = Math.hypot(target.x - zone.x, target.y - zone.y);
          if(dist <= zone.radius) {
            target.health = Math.max(0, target.health - zone.damagePerSecond * dt);
            if(target.health <= 0) {
              if(target.side === "left") { scoreRed++; } else { scoreBlue++; }
              updateScoreboard();
              clearAllEffects();
              resetRound();
            }
          }
        }
      }
    }
    function drawIceZones() {
      iceZones.forEach(zone => {
        ctx.save();
        let grad = ctx.createRadialGradient(zone.x, zone.y, zone.radius * 0.2, zone.x, zone.y, zone.radius);
        grad.addColorStop(0, "rgba(173,216,230,0.8)");
        grad.addColorStop(1, "rgba(0,191,255,0.2)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    
    // --- Update and Draw Thunder Zones (Mage Ultimate) ---
    function updateThunderZones() {
      const now = Date.now();
      for (let i = thunderZones.length - 1; i >= 0; i--) {
        let zone = thunderZones[i];
        if(now - zone.startTime > zone.duration) {
          thunderZones.splice(i, 1);
        } else {
          if(now - zone.lastTick >= zone.tickInterval) {
            zone.lastTick = now;
            let target = zone.owner === "left" ? player2 : player1;
            if(Date.now() < target.effectImmunityEnd) continue;
            let dist = Math.hypot(target.x - zone.x, target.y - zone.y);
            if(dist <= zone.radius) {
              target.health = Math.max(0, target.health - zone.damagePerTick);
              target.stunned = true;
              setTimeout(() => { target.stunned = false; }, 500);
              if(target.health <= 0) {
                if(target.side === "left") { scoreRed++; } else { scoreBlue++; }
                updateScoreboard();
                clearAllEffects();
                resetRound();
              }
            }
          }
        }
      }
    }
    function drawThunderZones() {
      thunderZones.forEach(zone => {
        ctx.save();
        // V·∫Ω v√πng s√©t m√†u t√≠m
        let alpha = 0.5 + 0.5 * Math.sin(Date.now()/200);
        ctx.strokeStyle = `rgba(128,0,128,${alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.stroke();
        // Ch·ªâ v·∫Ω tia s√©t n·∫øu ƒë·ªëi th·ªß ·ªü trong v√πng
        let target = zone.owner === "left" ? player2 : player1;
        let dist = Math.hypot(target.x - zone.x, target.y - zone.y);
        if(dist <= zone.radius) {
          for(let i=0; i<3; i++){
            let startX = zone.x + (Math.random()-0.5)*zone.radius;
            let startY = zone.y + (Math.random()-0.5)*zone.radius;
            let endX = startX + (Math.random()-0.5)*50;
            let endY = startY + (Math.random()-0.5)*50;
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          }
        }
        ctx.restore();
      });
    }
    
    // --- Effects for Attack and Counter ---
    const effects = [];
    class Effect {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.startTime = Date.now();
        this.duration = type === "attack" ? 150 : 500;
      }
      update(ctx, currentTime) {
        let elapsed = currentTime - this.startTime;
        let progress = elapsed / this.duration;
        if(progress > 1) return false;
        ctx.save();
        if(this.type === "attack") {
          const radius = 40;
          let alpha = 1 - progress;
          ctx.fillStyle = `rgba(255,100,100,${alpha})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, radius, 0, Math.PI*2);
          ctx.closePath();
          ctx.fill();
        } else if(this.type === "counter") {
          const radius = 25;
          let alpha = 1 - progress;
          ctx.strokeStyle = `rgba(255,215,0,${alpha})`;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.arc(this.x, this.y, radius, 0, Math.PI*2);
          ctx.stroke();
        }
        ctx.restore();
        return true;
      }
    }
    function updateEffects() {
      const now = Date.now();
      for(let i = effects.length - 1; i >= 0; i--) {
        if(!effects[i].update(ctx, now)) { effects.splice(i, 1); }
      }
    }
    
    // --- Skill Effects ---
    function showAttackEffect(player) {
      if(player.characterType === "knight") {
        effects.push(new Effect(player.x, player.y, "attack"));
      } else if(player.characterType === "archer") {
        showBulletEffect(player);
      }
    }
    function showCounterEffect(player) {
      effects.push(new Effect(player.x, player.y, "counter"));
    }
    // Mage attack: Fireball with gradient glow effect
    function showFireballEffect(player) {
      let fireball = {
        type: "fireball",
        x: player.x,
        y: player.y,
        dir: player.lastDir,
        speed: 15,
        maxDistance: 500,
        traveled: 0,
        owner: player.side,
        damage: player.attack
      };
      projectiles.push(fireball);
    }
    // Archer attack
    function showBulletEffect(player) {
      let bullet = {
        type: "bullet",
        x: player.x,
        y: player.y,
        dir: player.lastDir,
        speed: 15,
        maxDistance: 1000,
        traveled: 0,
        owner: player.side,
        damage: player.attack
      };
      projectiles.push(bullet);
    }
    
    // --- Projectiles ---
    const projectiles = [];
    function updateProjectiles() {
      for(let i = projectiles.length - 1; i >= 0; i--) {
        let proj = projectiles[i];
        let dx = proj.speed * Math.cos(proj.dir);
        let dy = proj.speed * Math.sin(proj.dir);
        proj.x += dx;
        proj.y += dy;
        proj.traveled += Math.sqrt(dx*dx + dy*dy);
        let opponent = proj.owner === "left" ? player2 : player1;
        let dist = Math.hypot(proj.x - opponent.x, proj.y - opponent.y);
        if(dist < opponent.size) {
          // Dodge check cho ƒë·ªëi th·ªß
          if(Date.now() < opponent.dodgeEnd || Math.random() < opponent.dodgeChance) {
            opponent.dodging = true;
            opponent.dodgeEnd = Date.now() + 500;
            opponent.effectImmunityEnd = Date.now() + 750;
            opponent.stunned = false;
            projectiles.splice(i, 1);
            continue;
          }
          let damage = proj.damage;
          if((proj.type === "bullet" || proj.type === "fireball") && Math.random() < ( (proj.owner==="left" ? player1 : player2).critChance )) {
            damage *= 1.5;
          }
          if(proj.type === "bullet" || proj.type === "fireball") {
            if(opponent.countering && opponent.characterType === "knight") {
              let attacker = proj.owner === "left" ? player1 : player2;
              attacker.health = Math.max(0, attacker.health - damage);
            } else {
              opponent.health = Math.max(0, opponent.health - damage);
            }
          } else if(proj.type === "bola") {
            opponent.stunned = true;
            opponent.stunStart = Date.now();
            setTimeout(() => { opponent.stunned = false; opponent.stunStart = null; }, proj.stunDuration);
          }
          projectiles.splice(i, 1);
          continue;
        }
        if(proj.traveled >= proj.maxDistance) {
          projectiles.splice(i, 1);
        }
      }
    }
    function drawProjectiles() {
      projectiles.forEach(proj => {
        ctx.save();
        if(proj.type === "bullet") {
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 6, 0, Math.PI*2);
          ctx.fill();
        } else if(proj.type === "fireball") {
          let grad = ctx.createRadialGradient(proj.x, proj.y, 2, proj.x, proj.y, 10);
          grad.addColorStop(0, "white");
          grad.addColorStop(0.5, "orange");
          grad.addColorStop(1, "red");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 10, 0, Math.PI*2);
          ctx.fill();
        } else if(proj.type === "bola") {
          ctx.fillStyle = "orange";
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 8, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      });
    }
    
    // --- Draw stun effect ---
    function drawStunEffect(player) {
      let time = Date.now();
      let alpha = 0.5 + 0.5 * Math.sin(time/200);
      ctx.save();
      ctx.font = "24px Arial";
      ctx.fillStyle = `rgba(255,255,0,${alpha})`;
      ctx.textAlign = "center";
      ctx.fillText("‚õìÔ∏è", player.x, player.y - player.size - 10);
      ctx.restore();
    }
    
    // --- Function clearAllEffects: gi·∫£i to√†n b·ªô hi·ªáu ·ª©ng v√† x√≥a tr·∫°ng th√°i cho√°ng/tr√≥i ch√¢n ---
    function clearAllEffects() {
      trails.length = 0;
      iceZones.length = 0;
      thunderZones.length = 0;
      effects.length = 0;
      projectiles.length = 0;
      if(player1) { player1.stunned = false; }
      if(player2) { player2.stunned = false; }
    }
    
    // --- Player Class ---
    class Player {
      constructor(x, y, color, controls, side, characterType) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.controls = controls;
        this.speed = 5;
        this.size = 15;
        this.characterType = characterType;
        if(characterType === "archer" || characterType === "mage") {
          this.health = 80;
          this.attack = 30;
          this.attackCooldown = 1000;
          this.ultimateActive = false;
        } else {
          this.health = 100;
          this.attack = 25;
          this.attackCooldown = 3000;
        }
        this.attacking = false;
        this.lastAttackTime = 0;
        this.attackProcessed = false;
        this.countering = false;
        this.lastCounterTime = 0;
        this.counterCooldown = 5000;
        this.side = side;
        this.name = (characterType === "archer") ? "X·∫° Th·ªß" : ((characterType === "mage") ? "Mage" : "Hi·ªáp sƒ©");
        this.lastDir = Math.PI/2;
        this.ultimateCooldown = 40000;
        this.lastUltimateTime = 0;
        this.stunned = false;
        this.stunStart = null;
        // Th√™m thu·ªôc t√≠nh t·ªâ l·ªá ch√≠ m·∫°ng v√† n√©
        this.critChance = 0.2;
        this.dodgeChance = 0.1;
        this.dodging = false;
        this.dodgeEnd = 0;
        this.effectImmunityEnd = 0;
      }
      move(keys) {
        if(this.stunned) return;
        let dx = 0, dy = 0;
        if(keys[this.controls.left] && this.x > this.size) { dx -= 1; this.x -= this.speed; }
        if(keys[this.controls.right] && this.x < canvas.width - this.size) { dx += 1; this.x += this.speed; }
        if(keys[this.controls.up] && this.y > this.size) { dy -= 1; this.y -= this.speed; }
        if(keys[this.controls.down] && this.y < canvas.height - this.size) { dy += 1; this.y += this.speed; }
        if(dx !== 0 || dy !== 0) { this.lastDir = Math.atan2(dy, dx); }
        // Attack
        if(keys[this.controls.attack] && Date.now() - this.lastAttackTime > ((this.ultimateActive && this.characterType==="archer") ? 0 : this.attackCooldown)) {
          this.attacking = true;
          this.attackProcessed = false;
          this.lastAttackTime = Date.now();
          if(this.characterType === "mage") {
            showFireballEffect(this);
          } else {
            showAttackEffect(this);
          }
          if(this.side === "left") {
            startCooldownEffect("left-cooldown", "left-cooldown-timer", 3000);
          } else {
            startCooldownEffect("right-cooldown", "right-cooldown-timer", 3000);
          }
          setTimeout(() => { this.attacking = false; }, 150);
        }
        // Counter
        if(keys[this.controls.counter] && Date.now() - this.lastCounterTime > this.counterCooldown) {
          this.countering = true;
          this.lastCounterTime = Date.now();
          showCounterEffect(this);
          if(this.side === "left") {
            startCooldownEffect("left-counter-cooldown", "left-counter-timer", 5000);
          } else {
            startCooldownEffect("right-counter-cooldown", "right-counter-timer", 5000);
          }
          if(this.characterType === "archer") {
            let bola = {
              type: "bola",
              x: this.x,
              y: this.y,
              dir: this.lastDir,
              speed: 10,
              maxDistance: 300,
              traveled: 0,
              owner: this.side,
              stunDuration: 3000
            };
            projectiles.push(bola);
          } else if(this.characterType === "mage") {
            let target = this.side === "left" ? player2 : player1;
            let iceZone = {
              type: "iceZone",
              x: target.x,
              y: target.y,
              radius: 50,
              damagePerSecond: 3,
              duration: 10000,
              startTime: Date.now(),
              lastUpdate: Date.now(),
              targetSide: target.side
            };
            iceZones.push(iceZone);
            target.stunned = true;
            setTimeout(() => { target.stunned = false; }, 2000);
          }
          setTimeout(() => { this.countering = false; }, 500);
        }
        // Ultimate
        if(keys[this.controls.ultimate] && Date.now() - this.lastUltimateTime > this.ultimateCooldown) {
          this.lastUltimateTime = Date.now();
          if(this.characterType === "archer") {
            this.ultimateActive = true;
            setTimeout(() => { this.ultimateActive = false; }, 5000);
          } else if(this.characterType === "mage") {
            this.ultimateActive = true;
            this.stunned = true;
            let thunderZone = {
              type: "thunderZone",
              x: this.x,
              y: this.y,
              radius: 300,
              duration: 10000,
              startTime: Date.now(),
              lastTick: Date.now(),
              owner: this.side,
              damagePerTick: 0.5 * this.attack, // 50% atk
              tickInterval: 1000
            };
            thunderZones.push(thunderZone);
            setTimeout(() => { this.ultimateActive = false; this.stunned = false; }, 10000);
          } else {
            this.useUltimate();
          }
          if(this.side === "left") {
            startCooldownEffect("left-ultimate-cooldown", "left-ultimate-timer", 40000);
          } else {
            startCooldownEffect("right-ultimate-cooldown", "right-ultimate-timer", 40000);
          }
        }
      }
      useUltimate() {
        const dashDistance = 400;
        let newX = this.x + dashDistance * Math.cos(this.lastDir);
        let newY = this.y + dashDistance * Math.sin(this.lastDir);
        newX = clamp(newX, this.size, canvas.width - this.size);
        newY = clamp(newY, this.size, canvas.height - this.size);
        const trail = {
          startX: this.x,
          startY: this.y,
          endX: newX,
          endY: newY,
          thickness: 20,
          owner: this.side,
          startTime: Date.now(),
          duration: 10000,
          lastUpdate: Date.now()
        };
        trails.push(trail);
        this.x = newX;
        this.y = newY;
      }
      checkCollision(opponent) {
        if(this.attacking && !this.attackProcessed) {
          const dx = opponent.x - this.x;
          const dy = opponent.y - this.y;
          const distanceSquared = dx*dx + dy*dy;
          const attackRange = 50;
          const effectiveRange = attackRange + opponent.size;
          if(distanceSquared < effectiveRange * effectiveRange) {
            // Dodge check: n·∫øu ƒë·ªëi th·ªß n√©, b·ªè qua s√°t th∆∞∆°ng
            if(Date.now() < opponent.dodgeEnd || Math.random() < opponent.dodgeChance) {
              opponent.dodging = true;
              opponent.dodgeEnd = Date.now() + 500;
              opponent.effectImmunityEnd = Date.now() + 750;
              opponent.stunned = false;
              return;
            }
            let damage = this.attack;
            if(Math.random() < this.critChance) {
              damage *= 1.5;
            }
            if(opponent.countering) {
              this.health = Math.max(0, this.health - damage);
              this.attackProcessed = true;
            } else {
              opponent.health = Math.max(0, opponent.health - damage);
              this.attackProcessed = true;
            }
            if(opponent.health <= 0) {
              if(opponent.side === "left") { scoreRed++; } else { scoreBlue++; }
              updateScoreboard();
              clearAllEffects();
              resetRound();
            }
            if(this.health <= 0) {
              if(this.side === "left") { scoreRed++; } else { scoreBlue++; }
              updateScoreboard();
              clearAllEffects();
              resetRound();
            }
          }
        }
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        this.drawHealthBar();
        this.drawName();
        if(this.stunned) { drawStunEffect(this); }
      }
      drawHealthBar() {
        ctx.fillStyle = "red";
        ctx.fillRect(this.x - 20, this.y - 30, 40, 5);
        ctx.fillStyle = "green";
        ctx.fillRect(this.x - 20, this.y - 30, (this.health/100)*40, 5);
      }
      drawName() {
        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.name, this.x, this.y - 40);
      }
    }
    
    // --- Th√™m thu·ªôc t√≠nh t·ªâ l·ªá ch√≠ m·∫°ng v√† n√© cho Player (m·∫∑c ƒë·ªãnh) ---
    // (C√°c gi√° tr·ªã n√†y ƒë√£ ƒë∆∞·ª£c g√°n trong constructor)
    
    // --- Bi·∫øn ch·ªçn class ---
    let selectedCharacterLeft = "knight", selectedCharacterRight = "knight";
    document.querySelectorAll("#left-character-select .character-option").forEach(option => {
      option.addEventListener("click", () => {
        document.querySelectorAll("#left-character-select .character-option").forEach(opt => opt.classList.remove("selected"));
        option.classList.add("selected");
        selectedCharacterLeft = option.getAttribute("data-character");
      });
    });
    document.querySelectorAll("#right-character-select .character-option").forEach(option => {
      option.addEventListener("click", () => {
        document.querySelectorAll("#right-character-select .character-option").forEach(opt => opt.classList.remove("selected"));
        option.classList.add("selected");
        selectedCharacterRight = option.getAttribute("data-character");
      });
    });
    
    // --- T·∫°o ng∆∞·ªùi ch∆°i ---
    let player1, player2;
    function createPlayers() {
      if(selectedCharacterLeft === "archer") {
        player1 = new Player(50,50,"blue",{ left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" },"left","archer");
      } else if(selectedCharacterLeft === "mage") {
        player1 = new Player(50,50,"blue",{ left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" },"left","mage");
      } else {
        player1 = new Player(50,50,"blue",{ left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" },"left","knight");
      }
      if(selectedCharacterRight === "archer") {
        player2 = new Player(750,550,"red",{ left:"ArrowLeft", right:"ArrowRight", up:"ArrowUp", down:"ArrowDown", attack:"Enter", counter:"/", ultimate:"ShiftRight" },"right","archer");
      } else if(selectedCharacterRight === "mage") {
        player2 = new Player(750,550,"red",{ left:"ArrowLeft", right:"ArrowRight", up:"ArrowUp", down:"ArrowDown", attack:"Enter", counter:"/", ultimate:"ShiftRight" },"right","mage");
      } else {
        player2 = new Player(750,550,"red",{ left:"ArrowLeft", right:"ArrowRight", up:"ArrowUp", down:"ArrowDown", attack:"Enter", counter:"/", ultimate:"ShiftRight" },"right","knight");
      }
    }
    function resetRound() {
      player1.health = (selectedCharacterLeft==="archer" || selectedCharacterLeft==="mage") ? 80 : 100;
      player2.health = (selectedCharacterRight==="archer" || selectedCharacterRight==="mage") ? 80 : 100;
      player1.x = 50; player1.y = 50;
      player2.x = 750; player2.y = 550;
      player1.lastUltimateTime = 0; player2.lastUltimateTime = 0;
      clearAllEffects();
    }
    function resetGame() { location.reload(); }
    
    function gameLoop() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      player1.move(keys);
      player2.move(keys);
      player1.checkCollision(player2);
      player2.checkCollision(player1);
      player1.draw();
      player2.draw();
      updateEffects();
      updateTrails();
      updateProjectiles();
      updateIceZones();
      updateThunderZones();
      drawProjectiles();
      drawIceZones();
      drawThunderZones();
      
      // N·∫øu m·ªôt b√™n HP ‚â§ 0, c·ªông ƒëi·ªÉm, gi·∫£i to√†n b·ªô hi·ªáu ·ª©ng v√† reset v√≤ng ch∆°i
      if(player1.health <= 0 || player2.health <= 0) {
        if(player1.health <= 0 && player2.health > 0) scoreBlue++;
        else if(player2.health <= 0 && player1.health > 0) scoreRed++;
        updateScoreboard();
        clearAllEffects();
        resetRound();
      }
      
      requestAnimationFrame(gameLoop);
    }
    
    document.getElementById("startButton").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("characterSelectScreen").style.display = "flex";
    });
    document.getElementById("confirmCharacterButton").addEventListener("click", () => {
      const p1Name = document.getElementById("player1Name").value.trim() || ((selectedCharacterLeft==="archer" || selectedCharacterLeft==="mage") ? "X·∫° Th·ªß/Mage" : "Hi·ªáp sƒ©");
      const p2Name = document.getElementById("player2Name").value.trim() || ((selectedCharacterRight==="archer" || selectedCharacterRight==="mage") ? "X·∫° Th·ªß/Mage" : "Hi·ªáp sƒ©");
      createPlayers();
      player1.name = p1Name;
      player2.name = p2Name;
      document.getElementById("characterSelectScreen").style.display = "none";
      gameLoop();
    });
  </script>
</body>
</html>
