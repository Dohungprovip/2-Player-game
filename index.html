<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple MOBA</title>
  <style>
    /* T·ªïng th·ªÉ */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e1e1e, #444);
      color: #fff;
    }
    /* Scoreboard ‚Äì hi·ªÉn th·ªã ƒëi·ªÉm chung */
    #scoreboard {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      z-index: 1001;
      background: rgba(0,0,0,0.7);
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.8);
    }
    /* N√∫t quay l·∫°i menu */
    #menuButton {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1001;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background: linear-gradient(135deg, #555, #777);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      transition: background 0.3s ease;
    }
    #menuButton:hover {
      background: linear-gradient(135deg, #777, #999);
    }
    /* Cooldown timer */
    .cooldown-timer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      opacity: 1 !important;
    }
    /* Canvas */
    canvas {
      display: block;
      margin: 80px auto 20px auto;
      border: 2px solid #fff;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
      background: #444;
    }
    /* Game Zones ‚Äì gi·ªØ nguy√™n v·ªã tr√≠ & style */
    .zone, .sword-zone, .u-zone, .special-zone {
      position: absolute;
      width: 80px;
      height: 80px;
      background: #555;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    .sword-zone { overflow: hidden; }
    .sword-zone::before {
      content: "‚öîÔ∏è";
      font-size: 50px;
      text-shadow: 0 0 5px rgba(255,215,0,0.8);
    }
    .counter-zone::before {
      content: "üõ°Ô∏è";
      font-size: 50px;
      text-shadow: 0 0 5px rgba(173,216,230,0.8);
    }
    .u-zone::before {
      content: "üíé";
      font-size: 50px;
      color: #fff;
    }
    #left-sword-zone { left: 20px; bottom: 20px; }
    #left-counter-zone { left: 120px; bottom: 20px; }
    #left-u-zone { left: 220px; bottom: 20px; }
    #right-sword-zone { right: 20px; bottom: 20px; }
    #right-counter-zone { right: 120px; bottom: 20px; }
    #right-u-zone { right: 220px; bottom: 20px; }
    #left-special-zone { left: 20px; bottom: 120px; }
    #right-special-zone { right: 20px; bottom: 120px; }
    .special-zone::before {
      content: "‚òù";
      font-size: 50px;
      text-shadow: 0 0 5px rgba(255,215,0,0.8);
    }
    .cooldown-overlay {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      top: 0;
      left: 0;
      opacity: 0;
      transition: height 0.3s ease, opacity 0.3s ease;
    }
    /* Overlay Screens chung */
    .overlay-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.5s ease;
      padding: 20px;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .overlay-screen input,
    .overlay-screen button {
      padding: 10px;
      margin: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
    }
    .overlay-screen input { width: 250px; }
    .overlay-screen button {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      background: linear-gradient(135deg, #555, #777);
      color: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      transition: background 0.3s ease;
    }
    .overlay-screen button:hover {
      background: linear-gradient(135deg, #777, #999);
    }
    /* ·∫®n giao di·ªán nh·∫≠p t√™n, ch·ªçn nh√¢n v·∫≠t */
    #nameScreen, #characterSelectScreen {
      display: none;
    }
    /* Giao di·ªán gh√©p tr·∫≠n v·ªõi spinner */
    #waitingScreen {
      display: none;
    }
    .spinner {
      border: 8px solid rgba(255,255,255,0.3);
      border-top: 8px solid white;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-top: 20px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Style cho n√∫t ch·ªçn class */
    .class-btn {
      padding: 10px 20px;
      margin: 10px;
      font-size: 18px;
      cursor: pointer;
      background: linear-gradient(135deg, #555, #777);
      border: none;
      border-radius: 5px;
      color: #fff;
      transition: background 0.3s ease;
    }
    .class-btn:hover {
      background: linear-gradient(135deg, #777, #999);
    }
    .class-btn.active {
      background: linear-gradient(135deg, #777, #aaa);
    }
    /* Skill slots cho local player */
    #skillContainer {
      position: fixed;
      right: 20px;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1002;
    }
    .skill-slot {
      position: relative;
      width: 60px;
      height: 60px;
      border: 2px solid #fff;
      border-radius: 10px;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .skill-icon {
      font-size: 32px;
      z-index: 1;
    }
  </style>
</head>
<body>
  <!-- Scoreboard -->
  <div id="scoreboard">Score: 0</div>
  <button id="menuButton">Quay l·∫°i menu</button>
  
  <!-- Start Screen -->
  <div id="startScreen" class="overlay-screen">
    <h1>Simple MOBA</h1>
    <div class="menu">
      <button id="startMenuButton">B·∫Øt ƒë·∫ßu</button>
      <button id="instructionButton">H∆∞·ªõng d·∫´n</button>
      <button id="infoButton">Th√¥ng tin nh√¢n v·∫≠t</button>
    </div>
  </div>
  
  <!-- Character Selection Screen -->
  <div id="characterSelectScreen" class="overlay-screen">
    <h1>Ch·ªçn Class</h1>
    <div class="menu">
      <button class="class-btn" data-class="knight">Knight</button>
      <button class="class-btn" data-class="archer">Archer</button>
      <button class="class-btn" data-class="mage">Mage</button>
    </div>
    <button id="nextButton">Ti·∫øp theo</button>
  </div>
  
  <!-- Instruction Screen (kh√¥ng thay ƒë·ªïi) -->
  <div id="instructionScreen" class="overlay-screen">
    <h1>H∆∞·ªõng d·∫´n</h1>
    <p>
      Di chuy·ªÉn: s·ª≠ d·ª•ng WASD cho local player, m≈©i t√™n cho ƒë·ªëi th·ªß<br>
      ƒê√°nh th∆∞·ªùng: Space (local) ‚Äì Enter (ƒë·ªëi th·ªß)<br>
      Skill 1: C (local) ‚Äì / (ƒë·ªëi th·ªß)<br>
      Skill 2: B (local) ‚Äì ' (ƒë·ªëi th·ªß)<br>
      Ultimate: V (local) ‚Äì ShiftRight (ƒë·ªëi th·ªß)
    </p>
    <button id="backFromInstruction">Quay l·∫°i</button>
  </div>
  
  <!-- Character Info Screen (kh√¥ng thay ƒë·ªïi) -->
  <div id="characterInfoScreen" class="overlay-screen">
    <h1>Th√¥ng tin nh√¢n v·∫≠t</h1>
    <div id="infoCharacterBoxes">
      <div class="info-box" data-type="knight">Knight</div>
      <div class="info-box" data-type="archer">Archer</div>
      <div class="info-box" data-type="mage">Mage</div>
    </div>
    <div id="infoRows">
      <div class="info-row"><span>Ch·ªâ s·ªë c∆° b·∫£n:</span><span id="infoRow1">HP: 300/280, ATK: 25/30, T·ªëc ƒë·ªô: 2</span></div>
      <div class="info-row"><span>Skill 1:</span><span id="infoRow2">
        Knight: ph·∫£n ƒë√≤n t·ªìn t·∫°i 1s<br>
        Archer: tr√≥i ch√¢n 2s<br>
        Mage: g√¢y s√°t th∆∞∆°ng 5/s v√† tr√≥i ch√¢n 2s
      </span></div>
      <div class="info-row"><span>Skill 2:</span><span id="infoRow3">
        Mage: khi√™n n∆∞·ªõc t·ªìn t·∫°i 3s
      </span></div>
      <div class="info-row"><span>Ultimate:</span><span id="infoRow4">
        Mage: g√¢y 50% ATK/s v√† cho√°ng 1s m·ªói 2s (10s)
      </span></div>
    </div>
    <button id="backFromInfo">Quay l·∫°i</button>
  </div>
  
  <!-- Waiting Screen: giao di·ªán gh√©p tr·∫≠n v·ªõi spinner -->
  <div id="waitingScreen" class="overlay-screen">
    <h1>ƒêang t√¨m tr·∫≠n...</h1>
    <div class="spinner"></div>
  </div>
  
  <!-- Canvas game -->
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <!-- Skill slots hi·ªÉn th·ªã ·ªü b√™n ph·∫£i (ch·ªâ local player th·∫•y) -->
  <div id="skillContainer">
    <div class="skill-slot" id="skill-attack">
      <div class="skill-icon">‚öîÔ∏è</div>
      <div class="cooldown-overlay" id="skill-attack-overlay">
        <div class="cooldown-timer" id="skill-attack-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-counter">
      <div class="skill-icon">üõ°Ô∏è</div>
      <div class="cooldown-overlay" id="skill-counter-overlay">
        <div class="cooldown-timer" id="skill-counter-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-special">
      <div class="skill-icon">‚≠ê</div>
      <div class="cooldown-overlay" id="skill-special-overlay">
        <div class="cooldown-timer" id="skill-special-timer"></div>
      </div>
    </div>
    <div class="skill-slot" id="skill-ultimate">
      <div class="skill-icon">‚ú¥</div>
      <div class="cooldown-overlay" id="skill-ultimate-overlay">
        <div class="cooldown-timer" id="skill-ultimate-timer"></div>
      </div>
    </div>
  </div>
  
  <script>
    // --- Global Variables ---
    let player;      // local player
    let opponent;    // opponent player
    let localName;   // t√™n ng∆∞·ªùi ch∆°i
    let selectedCharacterLeft = "knight"; // m·∫∑c ƒë·ªãnh knight
    let roomId;      // room id nh·∫≠n t·ª´ server
    const socket = io("https://game-cua-dohung.onrender.com");
    
    // Bi·∫øn ki·ªÉm so√°t tr·∫°ng th√°i s·∫µn s√†ng c·ªßa c·∫£ hai ng∆∞·ªùi ch∆°i
    let playerReady = false;
    let opponentReady = false;
    
    // --- ƒê·ªëi t∆∞·ª£ng l∆∞u tr·∫°ng th√°i ph√≠m ---
    let keys = {};
    document.addEventListener("keydown", (e) => {
      keys[e.key] = true;
      if (socket.connected) {
        socket.emit("player_move", { roomId, playerId: socket.id, key: e.key });
      }
    });
    document.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let score = 0;
    function updateScoreboard() {
      document.getElementById("scoreboard").textContent = `Score: ${score}`;
    }
    function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }
    
    // --- Skill Cooldown --- (hi·ªÉn th·ªã th·ªùi gian h·ªìi chi√™u)
    function startSkillCooldown(overlayId, timerId, duration) {
      const overlay = document.getElementById(overlayId);
      const timerElem = document.getElementById(timerId);
      overlay.style.opacity = "1";
      timerElem.style.opacity = "1";
      let startTime = Date.now();
      function update() {
        let elapsed = Date.now() - startTime;
        let remaining = Math.ceil((duration - elapsed) / 1000);
        timerElem.textContent = remaining > 0 ? remaining : "";
        if (elapsed < duration) {
          requestAnimationFrame(update);
        } else {
          overlay.style.opacity = "0";
          timerElem.textContent = "";
        }
      }
      update();
    }
    
    // --- C√°c hi·ªáu ·ª©ng, zones, projectiles (nh∆∞ c≈©) ---
    const iceZones = [];
    const thunderZones = [];
    const trails = [];
    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = lenSq !== 0 ? dot / lenSq : -1;
      let xx, yy;
      if (param < 0) { xx = x1; yy = y1; }
      else if (param > 1) { xx = x2; yy = y2; }
      else { xx = x1 + param * C; yy = y1 + param * D; }
      const dx = px - xx, dy = py - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function updateTrails() {
      const now = Date.now();
      for (let i = trails.length - 1; i >= 0; i--) {
        const trail = trails[i];
        ctx.save();
        const grad = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
        grad.addColorStop(0, "rgba(255,69,0,0.9)");
        grad.addColorStop(1, "rgba(255,140,0,0.9)");
        ctx.strokeStyle = grad;
        ctx.lineWidth = trail.thickness;
        ctx.shadowColor = "rgba(255,140,0,1)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(trail.startX, trail.startY);
        ctx.lineTo(trail.endX, trail.endY);
        ctx.stroke();
        ctx.restore();
        if (Date.now() - trail.startTime >= trail.duration) {
          trails.splice(i, 1);
        } else {
          trail.lastUpdate = Date.now();
        }
      }
    }
    function updateIceZones() {
      const now = Date.now();
      [player, opponent].forEach(target => {
        if(target) {
          iceZones.forEach((zone, index) => {
            if(now - zone.startTime > zone.duration) {
              iceZones.splice(index, 1);
            } else {
              let dt = (now - zone.lastUpdate) / 1000;
              zone.lastUpdate = now;
              let dist = Math.hypot(target.x - zone.x, target.y - zone.y);
              if(dist <= zone.radius) {
                target.health = Math.max(0, target.health - zone.damagePerSecond * dt);
                if(target.health <= 0) {
                  score++;
                  updateScoreboard();
                  clearAllEffects();
                  resetRound();
                }
              }
            }
          });
        }
      });
    }
    function drawIceZones() {
      iceZones.forEach(zone => {
        ctx.save();
        let grad = ctx.createRadialGradient(zone.x, zone.y, zone.radius * 0.2, zone.x, zone.y, zone.radius);
        grad.addColorStop(0, "rgba(173,216,230,0.8)");
        grad.addColorStop(1, "rgba(0,191,255,0.2)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function updateThunderZones() {
      const now = Date.now();
      [player, opponent].forEach(target => {
        if(target) {
          thunderZones.forEach((zone, index) => {
            if(now - zone.startTime > zone.duration) {
              thunderZones.splice(index, 1);
            } else {
              if(now - zone.lastTick >= zone.tickInterval) {
                zone.lastTick = now;
                let dist = Math.hypot(target.x - zone.x, target.y - zone.y);
                if(dist <= zone.radius) {
                  target.health = Math.max(0, target.health - zone.damagePerTick);
                  if(now - zone.lastStunTime >= 2000) {
                    zone.lastStunTime = now;
                    target.stunned = true;
                    setTimeout(() => { target.stunned = false; }, 1000);
                  }
                  if(target.health <= 0) {
                    score++;
                    updateScoreboard();
                    clearAllEffects();
                    resetRound();
                  }
                }
              }
            }
          });
        }
      });
    }
    function drawThunderZones() {
      thunderZones.forEach(zone => {
        ctx.save();
        let alpha = 0.5 + 0.5 * Math.sin(Date.now()/200);
        ctx.strokeStyle = `rgba(128,0,128,${alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      });
    }
    const effects = [];
    class Effect {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.startTime = Date.now();
        this.duration = type === "attack" ? 150 : 500;
      }
      update(ctx, currentTime) {
        let elapsed = currentTime - this.startTime;
        let progress = elapsed / this.duration;
        if(progress > 1) return false;
        ctx.save();
        if(this.type === "attack") {
          const radius = 40;
          let alpha = 1 - progress;
          ctx.fillStyle = `rgba(255,100,100,${alpha})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, radius, 0, Math.PI*2);
          ctx.closePath();
          ctx.fill();
        } else if(this.type === "counter") {
          const radius = 25;
          let alpha = 1 - progress;
          ctx.strokeStyle = `rgba(255,215,0,${alpha})`;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.arc(this.x, this.y, radius, 0, Math.PI*2);
          ctx.stroke();
        }
        ctx.restore();
        return true;
      }
    }
    function updateEffects() {
      const now = Date.now();
      for(let i = effects.length - 1; i >= 0; i--) {
        if(!effects[i].update(ctx, now)) { effects.splice(i, 1); }
      }
    }
    function showAttackEffect(player) {
      if(player.characterType === "knight") {
        effects.push(new Effect(player.x, player.y, "attack"));
        if(player.buffActive) {
          player.speed = player.baseSpeed;
          player.attack = player.baseAttack;
          player.buffActive = false;
        }
      } else if(player.characterType === "archer") {
        showBulletEffect(player);
      }
    }
    function showCounterEffect(player) {
      effects.push(new Effect(player.x, player.y, "counter"));
    }
    function showFireballEffect(player) {
      let fireball = {
        type: "fireball",
        x: player.x,
        y: player.y,
        dir: player.lastDir,
        speed: 15,
        maxDistance: 500,
        traveled: 0,
        owner: player.side,
        damage: player.attack
      };
      projectiles.push(fireball);
    }
    function showBulletEffect(player) {
      let bullet = {
        type: "bullet",
        x: player.x,
        y: player.y,
        dir: player.lastDir,
        speed: 15,
        maxDistance: 1000,
        traveled: 0,
        owner: player.side,
        damage: player.attack
      };
      projectiles.push(bullet);
    }
    const projectiles = [];
    function updateProjectiles() {
      for(let i = projectiles.length - 1; i >= 0; i--) {
        let proj = projectiles[i];
        let dx = proj.speed * Math.cos(proj.dir);
        let dy = proj.speed * Math.sin(proj.dir);
        proj.x += dx;
        proj.y += dy;
        proj.traveled += Math.sqrt(dx*dx + dy*dy);
        let dist = Math.hypot(proj.x - player.x, proj.y - player.y);
        if(dist < player.size) {
          if(Date.now() < player.dodgeEnd || Math.random() < player.dodgeChance) {
            player.dodging = true;
            player.dodgeEnd = Date.now() + 500;
            player.effectImmunityEnd = Date.now() + 750;
            player.stunned = false;
            projectiles.splice(i, 1);
            continue;
          }
          let damage = proj.damage;
          if((proj.type === "bullet" || proj.type === "fireball") && Math.random() < player.critChance) {
            damage *= 1.5;
          }
          if(proj.type === "bullet" || proj.type === "fireball") {
            player.health = Math.max(0, player.health - damage);
          } else if(proj.type === "bola") {
            player.stunned = true;
            player.stunStart = Date.now();
            setTimeout(() => { player.stunned = false; player.stunStart = null; }, proj.stunDuration);
          }
          projectiles.splice(i, 1);
          continue;
        }
        if(proj.traveled >= proj.maxDistance) {
          projectiles.splice(i, 1);
        }
      }
    }
    function drawProjectiles() {
      projectiles.forEach(proj => {
        ctx.save();
        if(proj.type === "bullet") {
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 6, 0, Math.PI*2);
          ctx.fill();
        } else if(proj.type === "fireball") {
          let grad = ctx.createRadialGradient(proj.x, proj.y, 2, proj.x, proj.y, 10);
          grad.addColorStop(0, "white");
          grad.addColorStop(0.5, "orange");
          grad.addColorStop(1, "red");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 10, 0, Math.PI*2);
          ctx.fill();
        } else if(proj.type === "bola") {
          ctx.fillStyle = "orange";
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, 8, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      });
    }
    function drawStunEffect(player) {
      let time = Date.now();
      let alpha = 0.5 + 0.5 * Math.sin(time/200);
      ctx.save();
      ctx.font = "24px Arial";
      ctx.fillStyle = `rgba(255,255,0,${alpha})`;
      ctx.textAlign = "center";
      ctx.fillText("‚õìÔ∏è", player.x, player.y - player.size - 10);
      ctx.restore();
    }
    function clearAllEffects() {
      trails.length = 0;
      iceZones.length = 0;
      thunderZones.length = 0;
      effects.length = 0;
      projectiles.length = 0;
      if(player) { player.stunned = false; player.immobilized = false; }
      if(opponent) { opponent.stunned = false; opponent.immobilized = false; }
    }
    // --- L·ªõp Player ---
    class Player {
      constructor(x, y, color, controls, side, characterType) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.controls = controls;
        this.speed = 2;
        this.baseSpeed = this.speed;
        this.size = 15;
        this.characterType = characterType;
        if(characterType === "archer" || characterType === "mage") {
          this.health = 280;
          this.maxHealth = 280;
          this.attack = 30;
          this.baseAttack = this.attack;
          this.attackCooldown = 3000;
          this.baseAttackCooldown = 3000;
          this.ultimateActive = false;
        } else {
          this.health = 300;
          this.maxHealth = 300;
          this.attack = 25;
          this.baseAttack = this.attack;
          this.attackCooldown = 3000;
          this.baseAttackCooldown = 3000;
        }
        this.attacking = false;
        this.lastAttackTime = 0;
        this.attackProcessed = false;
        this.countering = false;
        this.lastCounterTime = 0;
        this.counterCooldown = 5000;
        this.side = side;
        this.name = "";
        this.lastDir = Math.PI/2;
        this.ultimateCooldown = 40000;
        this.lastUltimateTime = 0;
        this.stunned = false;
        this.immobilized = false;
        this.stunStart = null;
        this.critChance = 0.2;
        this.dodgeChance = 0.1;
        this.dodging = false;
        this.dodgeEnd = 0;
        this.effectImmunityEnd = 0;
        this.attackDebuffs = [];
        this.lastSpecialTime = 0;
        this.specialCooldown = 5000;
        if(this.characterType === "knight") {
          this.phantomHealth = 0;
          this.phantomExpire = 0;
          this.immune = false;
          this.buffActive = false;
        }
        if(this.characterType === "mage") {
          this.phantomHealth = 0;
          this.phantomExpire = 0;
          this.waterShieldActive = false;
          this.waterShieldExpire = 0;
          this.attackDebuffActive = false;
          this.attackDebuffExpire = 0;
        }
        this.specialEffect = false;
      }
      drawHealthBar() {
        let totalWidth = 2 * this.size;
        let x = this.x - totalWidth / 2;
        let y = this.y - this.size - 15;
        if((this.characterType === "knight" || this.characterType === "mage") &&
           this.phantomHealth > 0 && Date.now() < this.phantomExpire) {
          let maxPhantom = (this.characterType === "knight") ? 100 : 20;
          let phantomRatio = this.phantomHealth / maxPhantom;
          let phantomBarHeight = 5;
          let phantomY = y - phantomBarHeight - 2;
          ctx.fillStyle = "white";
          ctx.fillRect(x, phantomY, totalWidth * phantomRatio, phantomBarHeight);
          ctx.strokeStyle = "black";
          ctx.strokeRect(x, phantomY, totalWidth, phantomBarHeight);
        }
        let maxHealth = this.maxHealth;
        let blockCount = Math.ceil(maxHealth / 50);
        let blockWidth = totalWidth / blockCount;
        let remainingHealth = this.health;
        for(let i = 0; i < blockCount; i++){
          let blockValue = 50;
          let fillRatio = Math.min(remainingHealth, blockValue) / blockValue;
          ctx.fillStyle = "red";
          ctx.fillRect(x + i * blockWidth, y, blockWidth, 7);
          ctx.fillStyle = "green";
          ctx.fillRect(x + i * blockWidth, y, blockWidth * fillRatio, 7);
          ctx.strokeStyle = "black";
          ctx.strokeRect(x + i * blockWidth, y, blockWidth, 7);
          remainingHealth -= blockValue;
          if(remainingHealth < 0) remainingHealth = 0;
        }
      }
      drawName() {
        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.name, this.x, this.y - 40);
      }
      draw() {
        if(this.attackDebuffs.length > 0) {
          ctx.save();
          ctx.fillStyle = "lightblue";
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.size - 25, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        if(this.specialEffect === "knight") {
          ctx.save();
          let pulse = Math.abs(Math.sin(Date.now()/200)) * 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 5 + pulse, 0, Math.PI * 2);
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 3;
          ctx.shadowColor = "yellow";
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.restore();
        } else if(this.specialEffect === "mage") {
          ctx.save();
          let pulse = Math.abs(Math.sin(Date.now()/200)) * 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 5 + pulse, 0, Math.PI * 2);
          ctx.strokeStyle = "skyblue";
          ctx.lineWidth = 3;
          ctx.shadowColor = "skyblue";
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.restore();
        }
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        this.drawHealthBar();
        this.drawName();
        if(this.stunned || this.immobilized) { drawStunEffect(this); }
      }
      move(keys) {
        let effectiveAttackCooldown = this.baseAttackCooldown;
        this.attackDebuffs = this.attackDebuffs.filter(d => d.expire > Date.now());
        this.attackDebuffs.forEach(d => { effectiveAttackCooldown += d.amount; });
        
        if(this.characterType === "knight" && this.immune) {
          this.stunned = false;
          this.immobilized = false;
        }
        if(this.characterType === "archer" || this.characterType === "mage") {
          if(this.attackDebuffActive && Date.now() > this.attackDebuffExpire) {
            this.attackCooldown = this.baseAttackCooldown;
            this.attackDebuffActive = false;
          }
        }
        if(!this.immobilized) {
          if(keys[this.controls.left] && this.x > this.size) { this.x -= this.speed; }
          if(keys[this.controls.right] && this.x < canvas.width - this.size) { this.x += this.speed; }
          if(keys[this.controls.up] && this.y > this.size) { this.y -= this.speed; }
          if(keys[this.controls.down] && this.y < canvas.height - this.size) { this.y += this.speed; }
          if(keys[this.controls.left] || keys[this.controls.right] || keys[this.controls.up] || keys[this.controls.down]) {
            this.lastDir = Math.atan2((keys[this.controls.down] ? 1 : 0) - (keys[this.controls.up] ? 1 : 0),
                                       (keys[this.controls.right] ? 1 : 0) - (keys[this.controls.left] ? 1 : 0));
          }
        }
        // X·ª≠ l√Ω t·∫•n c√¥ng (attack)
        if(keys[this.controls.attack] && Date.now() - this.lastAttackTime > ((this.ultimateActive && this.characterType==="archer") ? 0 : effectiveAttackCooldown)) {
          this.attacking = true;
          this.attackProcessed = false;
          this.lastAttackTime = Date.now();
          if(this.characterType === "mage") { showFireballEffect(this); }
          else { showAttackEffect(this); }
          startSkillCooldown("skill-attack-overlay", "skill-attack-timer", 3000);
          setTimeout(() => { this.attacking = false; }, 150);
          if(this.characterType === "knight" && this.buffActive) {
            this.speed = this.baseSpeed;
            this.attack = this.baseAttack;
            this.buffActive = false;
          }
        }
        // X·ª≠ l√Ω counter
        if(keys[this.controls.counter] && Date.now() - this.lastCounterTime > this.counterCooldown) {
          this.countering = true;
          this.lastCounterTime = Date.now();
          showCounterEffect(this);
          startSkillCooldown("skill-counter-overlay", "skill-counter-timer", 3000);
          if(this.characterType === "archer") {
            let bola = {
              type: "bola",
              x: this.x,
              y: this.y,
              dir: this.lastDir,
              speed: 10,
              maxDistance: 300,
              traveled: 0,
              owner: this.side,
              stunDuration: 2000
            };
            projectiles.push(bola);
          } else if(this.characterType === "mage") {
            let iceZone = {
              type: "iceZone",
              x: player.x + 50,
              y: player.y,
              radius: 50,
              damagePerSecond: 5,
              duration: 2000,
              startTime: Date.now(),
              lastUpdate: Date.now(),
              targetSide: player.side
            };
            iceZones.push(iceZone);
            player.immobilized = true;
            setTimeout(() => { player.immobilized = false; }, 2000);
          }
          setTimeout(() => { this.countering = false; }, 1000);
        }
        // X·ª≠ l√Ω Ultimate
        if(keys[this.controls.ultimate] && Date.now() - this.lastUltimateTime > this.ultimateCooldown) {
          this.lastUltimateTime = Date.now();
          if(this.characterType === "archer") {
            this.ultimateActive = true;
            setTimeout(() => { this.ultimateActive = false; }, 5000);
          } else if(this.characterType === "mage") {
            this.ultimateActive = true;
            this.immobilized = true;
            this.stunned = true;
            let thunderZone = {
              type: "thunderZone",
              x: this.x,
              y: this.y,
              radius: 300,
              duration: 10000,
              startTime: Date.now(),
              lastTick: Date.now(),
              lastStunTime: Date.now(),
              owner: this.side,
              damagePerTick: 0.5 * this.attack,
              tickInterval: 1000
            };
            thunderZones.push(thunderZone);
            setTimeout(() => { this.ultimateActive = false; this.stunned = false; this.immobilized = false; }, 10000);
          } else if(this.characterType === "knight") {
            let healAmount = 50;
            this.health = Math.min(this.health + healAmount, this.maxHealth);
            this.phantomHealth = 100;
            this.phantomExpire = Date.now() + 20000;
            this.immune = true;
            setTimeout(() => { this.immune = false; }, 20000);
            let trail = {
              startX: this.x,
              startY: this.y,
              endX: this.x,
              endY: this.y,
              thickness: 20,
              owner: this.side,
              startTime: Date.now(),
              duration: 10000,
              lastUpdate: Date.now()
            };
            trails.push(trail);
          }
          startSkillCooldown("skill-ultimate-overlay", "skill-ultimate-timer", 40000);
        }
        // X·ª≠ l√Ω Special (ph√≠m "b")
        if(keys["b"] && Date.now() - this.lastSpecialTime >= this.specialCooldown) {
          this.lastSpecialTime = Date.now();
          triggerSpecialZone();
        }
      }
      checkCollision(opponent) { }
    }
    // --- T·∫°o ƒë·ªëi t∆∞·ª£ng player ---
    function createLocalPlayer(assignedColor) {
      if(selectedCharacterLeft === "archer") {
        player = new Player(50,50, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "archer");
      } else if(selectedCharacterLeft === "mage") {
        player = new Player(50,50, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "mage");
      } else {
        player = new Player(50,50, assignedColor, { left:"a", right:"d", up:"w", down:"s", attack:" ", counter:"c", ultimate:"v" }, "left", "knight");
      }
      player.name = localName;
    }
    function createOpponentPlayer(opponentData, oppColor) {
      let oppChar = opponentData.character || "knight";
      opponent = new Player(750,550, oppColor, { left:"ArrowLeft", right:"ArrowRight", up:"ArrowUp", down:"ArrowDown", attack:"Enter", counter:"/", ultimate:"ShiftRight" }, "right", oppChar);
      opponent.name = opponentData.name;
    }
    function resetRound() {
      if(player) { 
        player.health = (player.characterType === "archer" || player.characterType === "mage") ? 280 : 300;
        player.x = 50; player.y = 50;
        player.lastUltimateTime = 0;
      }
      if(opponent) {
        opponent.health = (opponent.characterType === "archer" || opponent.characterType === "mage") ? 280 : 300;
        opponent.x = 750; opponent.y = 550;
        opponent.lastUltimateTime = 0;
      }
      clearAllEffects();
    }
    function resetGame() { location.reload(); }
    
    // --- S·ª± ki·ªán li√™n quan ƒë·∫øn x√°c nh·∫≠n s·∫µn s√†ng c·ªßa c·∫£ hai ng∆∞·ªùi ch∆°i ---
    socket.on("match_found", ({ roomId: rId, opponent: oppData, color }) => {
      roomId = rId;
      let localColor = color;
      let oppColor = (color === "blue") ? "red" : "blue";
      createLocalPlayer(localColor);
      createOpponentPlayer(oppData, oppColor);
      
      // Hi·ªÉn th·ªã x√°c nh·∫≠n tr∆∞·ªõc khi v√†o tr·∫≠n
      if (confirm(`üéÆ ƒê·ªëi th·ªß c·ªßa b·∫°n: ${oppData.name}. Nh·∫•n OK ƒë·ªÉ b·∫Øt ƒë·∫ßu.`)) {
        playerReady = true;
        socket.emit("player_ready", { roomId });
      }
      
      // Hi·ªÉn th·ªã m√†n h√¨nh ch·ªù cho ƒë·∫øn khi c·∫£ hai s·∫µn s√†ng
      document.getElementById("waitingScreen").style.display = "flex";
    });
    
    // Khi c·∫£ hai ng∆∞·ªùi ch∆°i ƒë√£ s·∫µn s√†ng
    socket.on("both_players_ready", () => {
      document.getElementById("waitingScreen").style.display = "none";
      gameLoop();
    });
    
    // C·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªông c·ªßa ƒë·ªëi th·ªß
    socket.on("update_opponent_position", (data) => {
      if (opponent) {
        opponent.x = data.x;
        opponent.y = data.y;
      }
    });
    
    // L·∫Øng nghe di chuy·ªÉn c·ªßa ng∆∞·ªùi ch∆°i v√† g·ª≠i l√™n server
    function handlePlayerMovement() {
      if (player) {
        let prevX = player.x;
        let prevY = player.y;
        player.move(keys);
        if (player.x !== prevX || player.y !== prevY) {
          socket.emit("player_moved", { roomId, x: player.x, y: player.y });
        }
      }
    }
    
    // --- V√≤ng l·∫∑p game ---
    function gameLoop() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      handlePlayerMovement();
      if(player) player.draw();
      if(opponent) opponent.draw();
      updateEffects();
      updateTrails();
      updateProjectiles();
      updateIceZones();
      updateThunderZones();
      drawProjectiles();
      drawIceZones();
      drawThunderZones();
      if(player && opponent) {
        if(player.health <= 0 || opponent.health <= 0) {
          score++;
          updateScoreboard();
          clearAllEffects();
          resetRound();
        }
      }
      requestAnimationFrame(gameLoop);
    }
    
    function triggerSpecialZone() {
      startSkillCooldown("skill-special-overlay", "skill-special-timer", 5000);
      if(player) {
        if(player.characterType === "knight") {
          player.speed = player.baseSpeed * 1.3;
          player.attack = player.baseAttack * 1.1;
          player.buffActive = true;
          player.specialEffect = "knight";
          setTimeout(() => { 
              player.buffActive = false; 
              player.specialEffect = false;
              player.speed = player.baseSpeed; 
              player.attack = player.baseAttack;
          }, 5000);
        } else if(player.characterType === "archer") {
          let dash = 200;
          player.x += dash * Math.cos(player.lastDir);
          player.y += dash * Math.sin(player.lastDir);
          player.x = clamp(player.x, player.size, canvas.width - player.size);
          player.y = clamp(player.y, player.size, canvas.height - player.size);
        } else if(player.characterType === "mage") {
          player.waterShieldActive = true;
          player.waterShieldExpire = Date.now() + 3000;
          player.phantomHealth = 20;
          player.specialEffect = "mage";
          setTimeout(() => { 
              player.specialEffect = false;
              player.waterShieldActive = false;
          }, 3000);
        }
      }
    }
    
    // --- S·ª± ki·ªán chuy·ªÉn m√†n h√¨nh ---
    document.getElementById("instructionButton").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("instructionScreen").style.display = "flex";
    });
    document.getElementById("infoButton").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("characterInfoScreen").style.display = "flex";
    });
    document.getElementById("backFromInstruction").addEventListener("click", () => {
      document.getElementById("instructionScreen").style.display = "none";
      document.getElementById("startScreen").style.display = "flex";
    });
    document.getElementById("backFromInfo").addEventListener("click", () => {
      document.getElementById("characterInfoScreen").style.display = "none";
      document.getElementById("startScreen").style.display = "flex";
    });
    // Khi nh·∫•n n√∫t "B·∫Øt ƒë·∫ßu" t·ª´ startScreen, chuy·ªÉn sang giao di·ªán ch·ªçn class
    document.getElementById("startMenuButton").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("characterSelectScreen").style.display = "flex";
    });
    // L·∫Øng nghe s·ª± ki·ªán ch·ªçn class
    const classButtons = document.querySelectorAll(".class-btn");
    classButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        selectedCharacterLeft = btn.getAttribute("data-class");
        classButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
      });
    });
    // Khi nh·∫•n n√∫t "Ti·∫øp theo" trong giao di·ªán ch·ªçn class
    document.getElementById("nextButton").addEventListener("click", () => {
      localName = prompt("Nh·∫≠p t√™n c·ªßa b·∫°n:") || "Player";
      socket.emit("find_match", { name: localName, character: selectedCharacterLeft });
      document.getElementById("characterSelectScreen").style.display = "none";
      document.getElementById("waitingScreen").style.display = "flex";
    });
    
    socket.on("opponent_left", () => {
      alert("‚ùå ƒê·ªëi th·ªß ƒë√£ r·ªùi kh·ªèi tr·∫≠n ƒë·∫•u!");
      location.reload();
    });
    socket.on("update_game", ({ playerId, key }) => {
      let target = (playerId === socket.id) ? player : opponent;
      if (key === "ArrowLeft" || key === "a") target.x -= 5;
      if (key === "ArrowRight" || key === "d") target.x += 5;
      if (key === "ArrowUp" || key === "w") target.y -= 5;
      if (key === "ArrowDown" || key === "s") target.y += 5;
    });
    document.getElementById("menuButton").addEventListener("click", () => {
      location.reload();
    });
  </script>
</body>
</html>
